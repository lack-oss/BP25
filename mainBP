task.spawn(function()
local player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local plrs = game:GetService("Players")
local lp = plrs.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer

-- Screen GUI
local screenGui = Instance.new("ScreenGui")
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- UI Frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 300, 0, 250)
frame.Position = UDim2.new(0.5, -150, 0.5, -125)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BackgroundTransparency = 0.1
frame.Visible = false
frame.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 3)
uiCorner.Parent = frame

local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(220, 20, 60)
stroke.Parent = frame

-- Floating Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 35, 0, 35)
toggleButton.Position = UDim2.new(1, -45, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.Text = "DAY"
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 14
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Visible = true
toggleButton.Parent = screenGui

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleButton

-- Tabs Section
local tabFrame = Instance.new("Frame")
tabFrame.Size = UDim2.new(1, 0, 0, 30)
tabFrame.Position = UDim2.new(0, 0, 0, 0)
tabFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
tabFrame.Parent = frame

-- Function to create tab buttons
local function createTabButton(name, position)
  local button = Instance.new("TextButton")
  button.Text = name
  button.Size = UDim2.new(0.25, -5, 0, 25)
  button.Position = UDim2.new(position, 5, 0, 2)
  button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
  button.Font = Enum.Font.GothamBold
  button.TextColor3 = Color3.fromRGB(200, 200, 200)
  button.TextSize = 12
  button.Parent = tabFrame

  local corner = Instance.new("UICorner")
  corner.CornerRadius = UDim.new(0, 6)
  corner.Parent = button

  return button
end

-- Create 4 tab buttons
local mainTabButton = createTabButton("Solo", 0)
local settingsTabButton = createTabButton("Duos", 0.18)
local featuresTabButton = createTabButton("Etc", 0.36)
local aboutTabButton = createTabButton("More", 0.54)
local detailsTabButton = createTabButton("Extra", 0.72)

-- Create the actual tab contents
local function createTab(parent)
  local tab = Instance.new("Frame")
  tab.Size = UDim2.new(1, 0, 1, -30)
  tab.Position = UDim2.new(0, 0, 0, 30)
  tab.BackgroundTransparency = 1
  tab.Parent = parent
  tab.Visible = false
  return tab
end

local mainTab = createTab(frame)
local settingsTab = createTab(frame)
local featuresTab = createTab(frame)
local aboutTab = createTab(frame)
local detailsTab = createTab(frame)

mainTab.Visible = true -- Default tab

-- Function to create toggle buttons
local function createToggleButton(text, parent, position)
  local button = Instance.new("TextButton")
  button.Size = UDim2.new(1, -10, 0, 25)
  button.Position = UDim2.new(0, 5, 0, position)
  button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
  button.Font = Enum.Font.GothamBold
  button.TextColor3 = Color3.fromRGB(200, 200, 200)
  button.TextSize = 12
  button.Text = text .. ": OFF"
  button.Parent = parent

  local corner = Instance.new("UICorner")
  corner.CornerRadius = UDim.new(0, 6)
  corner.Parent = button

  return button
end

-- Main Tab Section
-- Add Toggle Buttons for Each Tab
local aimbotButton = createToggleButton("Kill Aura & Always Hit", mainTab, 5)
local killAuraButton = createToggleButton("Kill Aura", mainTab, 35)
local extraButton = createToggleButton("Legit Auto Throw", mainTab, 65)
local alwaysHitButton = createToggleButton("Register Hit (Body)", mainTab, 95)
local alwaysHit2Button = createToggleButton("Register Hit (Head)", mainTab, 125)
local reachButton = createToggleButton("Auto Reach", mainTab, 155)
local alwaysHit3Button = createToggleButton("Register Hit (All Body Parts)", mainTab, 185)

-- Settings Tab Section
local extra2Button = createToggleButton("Legit Auto Throw (Duos)", settingsTab, 5)
local duoAlwaysHitButton = createToggleButton("Register Hit Duos (Body)", settingsTab, 35)
local duoAlwaysHit2Button = createToggleButton("Register Hit Duos (Head)", settingsTab, 65)
local reach2Button = createToggleButton("Auto Reach Duos", settingsTab, 95)
local duoAlwaysHit3Button = createToggleButton("Register Hit Duos (All Body Parts)", settingsTab, 125)
local bulbButton = createToggleButton("Auto Throw Bulb Duos", settingsTab, 155)
local bulb2Button = createToggleButton("Auto Throw Bulb", settingsTab, 185)

-- Features Tab Section
local radiusStabButton = createToggleButton("Radius Auto Stab", featuresTab, 5)
local radiusStab2Button = createToggleButton("Radius Auto Stab (Duos)", featuresTab, 35)
local killAura2Button = createToggleButton("Kill Aura Duos", featuresTab, 65)

-- About Tab Section
local bulb3Button = createToggleButton("Auto Throw Bulb V2", aboutTab, 5)
local bulb4Button = createToggleButton("Auto Throw Bulb V2 Head", aboutTab, 35)
local bulbDuo1Button = createToggleButton("Auto Throw Bulb Duos V2", aboutTab, 65)
local bulbDuo2Button = createToggleButton("Auto Throw Bulb Duos V2 Head", aboutTab, 95)
local bodyButton = createToggleButton("Head/Body Semi", aboutTab, 125)
local expanderButton = createToggleButton("Hitbox Expander", aboutTab, 155)

-- Details Tab Section
local anotherButton = createToggleButton("Legit Auto Throw V2", detailsTab, 5)
local headHitButton = createToggleButton("Legit Auto Throw V2 (Head)", detailsTab, 35)
local forceButton = createToggleButton("Force Players to Kill (Secret)", detailsTab, 65)
local force2Button = createToggleButton("Force Players to Kill (Public)", detailsTab, 95)
local duoHit1Button = createToggleButton("Legit Auto Throw Duos V2", detailsTab, 125)
local duoHit2Button = createToggleButton("Legit Auto Throw Duos V2 (Head)", detailsTab, 155)
local fullBrightButton = createToggleButton("Full Bright", detailsTab, 185)

-- helpers
function tools(plr)
  local bp = plr:FindFirstChildOfClass("Backpack")
  local inBP = bp and bp:FindFirstChild("blade") or bp and bp:FindFirstChild("Blade")
  local inHand = plr.Character and (plr.Character:FindFirstChild("blade") or plr.Character:FindFirstChild("Blade"))
  return inHand or inBP
end

function getRoot(char)
  return char:FindFirstChild("HumanoidRootPart")
  or char:FindFirstChild("Torso")
  or char:FindFirstChild("UpperTorso")
end

function playerHasBlade(p)
  local tool = p.Character and p.Character:FindFirstChildOfClass("Tool")
  if tool and tool.Name:lower():find("blade") then return true end

  local bp = p:FindFirstChildOfClass("Backpack")
  if bp then
    for _, t in ipairs(bp:GetChildren()) do
      if t:IsA("Tool") and t.Name:lower():find("blade") then
        return true
      end
    end
  end
  return false
end

local TweenService = game:GetService("TweenService")

function attachBehind(speaker, target, dist)
  local char = speaker.Character
  local hrp = getRoot(char)
  local thrp = getRoot(target.Character)
  if not (hrp and thrp) then return end

  local backPos = thrp.Position - thrp.CFrame.LookVector * dist
  local newCFrame = CFrame.new(backPos, thrp.Position)

  local tween = TweenService:Create(hrp, TweenInfo.new(0.05, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {CFrame = newCFrame})
  tween:Play()
  tween.Completed:Connect(function()
  local tool = tools(speaker)
  if tool then
    tool.Parent = char
    fireTap() -- Tap right after tween finishes
  else
    notify("Tool Required", "You need to hold a tool to stab.")
  end
  end)
end

local fireTapRunning = false

function fireTap()
  if fireTapRunning then return end
  fireTapRunning = true

  task.spawn(function()
  local VIM = game:GetService("VirtualInputManager")

  while fireTapRunning do
    VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
    task.wait(0.1)
  end
  end)
end

function stopFireTap()
  fireTapRunning = false
end

local function stopFireTapOnDeath(character)
  local humanoid = character:FindFirstChildOfClass("Humanoid")
  if humanoid then
    humanoid.Died:Connect(function()
    stopFireTap()  -- Stop fireTap when the character dies
    end)
  end
end

-- Setup on current character if exists
if Players.LocalPlayer.Character then
  stopFireTapOnDeath(Players.LocalPlayer.Character)
end

-- Setup on respawn
Players.LocalPlayer.CharacterAdded:Connect(function(char)
stopFireTapOnDeath(char)  -- Ensure fireTap stops when the player respawns
fireTapRunning = false  -- Reset the fireTapRunning flag when respawning
end)

-- Feature states
local features = {
  ["Kill Aura & Always Hit"] = { button = aimbotButton, state = false, toggleFunction = function(state)
  aimbotActive = state

  if state then
    game:GetService("StarterGui"):SetCore("SendNotification", {
      Title = "Kill Aura // Always Hit",
      Text = "Loaded! Always hit will trade ban you.",
      Duration = 3;
    })

    loadstring(game:HttpGet(("https://pastebin.com/raw/7c8Bw0ve"), true))()
  end
end
},

["Register Hit Duos (Body)"] = {
    button = duoAlwaysHitButton,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHitActive = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Body hits enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local function GetSkid()
                local myTeamColor = lp.TeamColor
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        if not (myTeamColor and plr.TeamColor and plr.TeamColor == myTeamColor) then
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                            if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                                return plr
                            end
                        end
                    end
                end
                return nil
            end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 4  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            --     ULTRA-STABLE KILLFUNC SYSTEM (AUTO-RECOVERY, NEVER BREAKS)
            ------------------------------------------------------------------

            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end

                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()

                return false
            end

            ------------------------------------------------------------------
            -- WATCHDOG (NEVER LETS THE SCRIPT DIE)
            ------------------------------------------------------------------
            task.spawn(function()
                while duoAlwaysHitActive do
                    if not KillFunc then
                        FindKillFunc()
                    end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (UNBREAKABLE HIT REGISTER) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval at 20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not duoAlwaysHitActive then return end

                    -- dynamically adjust interval: slower at low FPS, faster at high FPS
                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)

                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if duoHitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("HumanoidRootPart")
                            if part then
                                safe(function()
                                    local ok = TryKill(part)
                                    if not ok then
                                        safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

["Register Hit Duos (Head)"] = {
    button = duoAlwaysHit2Button,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHit2Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Headshots enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local function GetSkid()
                local myTeamColor = lp.TeamColor
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        if not (myTeamColor and plr.TeamColor and plr.TeamColor == myTeamColor) then
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                            if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                                return plr
                            end
                        end
                    end
                end
                return nil
            end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 4  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            --     ULTRA-STABLE KILLFUNC SYSTEM (AUTO-RECOVERY, NEVER BREAKS)
            ------------------------------------------------------------------

            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end

                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()

                return false
            end

            ------------------------------------------------------------------
            -- WATCHDOG (NEVER LETS THE SCRIPT DIE)
            ------------------------------------------------------------------
            task.spawn(function()
                while duoAlwaysHit2Active do
                    if not KillFunc then
                        FindKillFunc()
                    end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (UNBREAKABLE HIT REGISTER) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval at 20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not duoAlwaysHit2Active then return end

                    -- dynamically adjust interval: slower at low FPS, faster at high FPS
                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)

                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if duoHitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("Head")
                            if part then
                                safe(function()
                                    local ok = TryKill(part)

if ok then
    -- Only spawn ghost knife WHEN the kill actually succeeds
    local startPos = lp.Character.Blade.Position
    local finalPos = computePassThrough(part)

    spawnGhostKnife(startPos, finalPos)
else
    -- fallback (same as yours)
    safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

["Register Hit (Body)"] = {
    button = alwaysHitButton,
    state = false,
    toggleFunction = function(state)
        alwaysHitActive = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Body hits enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local function GetSkid()
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                        if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                            return plr
                        end
                    end
                end
                return nil
            end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 4  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            --     ULTRA-STABLE KILLFUNC SYSTEM (AUTO-RECOVERY, NEVER BREAKS)
            ------------------------------------------------------------------

            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end

                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()

                return false
            end

            ------------------------------------------------------------------
            -- WATCHDOG (NEVER LETS THE SCRIPT DIE)
            ------------------------------------------------------------------
            task.spawn(function()
                while alwaysHitActive do
                    if not KillFunc then
                        FindKillFunc()
                    end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (UNBREAKABLE HIT REGISTER) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval at ~20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not alwaysHitActive then return end

                    -- dynamically adjust interval: slower at low FPS, faster at high FPS
                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)

                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if hitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("HumanoidRootPart")
                            if part then
                                safe(function()
                                    local ok = TryKill(part)

if ok then
    -- Only spawn ghost knife WHEN the kill actually succeeds
    local startPos = lp.Character.Blade.Position
    local finalPos = computePassThrough(part)

    spawnGhostKnife(startPos, finalPos)
else
    -- fallback (same as yours)
    safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

["Register Hit (Head)"] = {
    button = alwaysHit2Button,
    state = false,
    toggleFunction = function(state)
        alwaysHit2Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Headshots enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local function GetSkid()
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                        if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                            return plr
                        end
                    end
                end
                return nil
            end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 4  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            --     ULTRA-STABLE KILLFUNC SYSTEM (AUTO-RECOVERY, NEVER BREAKS)
            ------------------------------------------------------------------

            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end

                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()

                return false
            end

            ------------------------------------------------------------------
            -- WATCHDOG (NEVER LETS THE SCRIPT DIE)
            ------------------------------------------------------------------
            task.spawn(function()
                while alwaysHit2Active do
                    if not KillFunc then
                        FindKillFunc()
                    end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (UNBREAKABLE HIT REGISTER) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval at ~20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not alwaysHit2Active then return end

                    -- dynamically adjust interval: slower at low FPS, faster at high FPS
                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)

                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if hitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("Head")
                            if part then
                                safe(function()
                                    local ok = TryKill(part)

if ok then
    -- Only spawn ghost knife WHEN the kill actually succeeds
    local startPos = lp.Character.Blade.Position
    local finalPos = computePassThrough(part)

    spawnGhostKnife(startPos, finalPos)
else
    -- fallback (same as yours)
    safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

["Register Hit (All Body Parts)"] = {
    button = alwaysHit3Button,
    state = false,
    toggleFunction = function(state)
        alwaysHit3Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Cycling Body Hits Enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            ------------------------------------------------------------------
            -- GET NEAREST VALID TARGET
            ------------------------------------------------------------------
local function GetSkid()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= lp and plr.Character then
            local character = plr.Character
            local backpack = plr:FindFirstChildOfClass("Backpack")

            local blade =
                character:FindFirstChild("Blade")
                or (backpack and backpack:FindFirstChild("Blade"))

            local hum = character:FindFirstChild("Humanoid")

            if blade and hum and hum.Health > 0 then
                return plr
            end
        end
    end
    return nil
end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 6  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            -- ULTRA-STABLE KILLFUNC SYSTEM (AUTO RECOVERY)
            ------------------------------------------------------------------
            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- R6 BODY PART CYCLE (F MODE)
            ------------------------------------------------------------------
            local cycleIndex = 1
            local cycleOrder = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}

            local function GetNextR6Part(character)
                for i = 1, 6 do
                    local partName = cycleOrder[cycleIndex]
                    cycleIndex = cycleIndex % 6 + 1
                    local part = character:FindFirstChild(partName)
                    if part then return part end
                end
                return character:FindFirstChild("HumanoidRootPart")
            end

            ------------------------------------------------------------------
            -- WATCHDOG
            ------------------------------------------------------------------
            task.spawn(function()
                while alwaysHit3Active do
                    if not KillFunc then FindKillFunc() end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (CYCLING BODY PARTS) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval at ~20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not alwaysHit3Active then return end

                    -- dynamically adjust interval: slower at low FPS, faster at high FPS
                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)

                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if hitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = GetNextR6Part(target.Character)
                            if part then
                                safe(function()
                                    local ok = TryKill(part)

if ok then
    -- Only spawn ghost knife WHEN the kill actually succeeds
    local startPos = lp.Character.Blade.Position
    local finalPos = computePassThrough(part)

    spawnGhostKnife(startPos, finalPos)
else
    -- fallback (same as yours)
    safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

["Register Hit Duos (All Body Parts)"] = {
    button = duoAlwaysHit3Button,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHit3Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Cycling Body Hits Enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            -----------------------------------------------------
-- Synced Target Picker (Perfectly matches throw logic)
-----------------------------------------------------
local myTeamColor = lp.TeamColor
local Camera = workspace.CurrentCamera

local function GetSkid()
    local closestPart = nil
    local bestDist = math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= lp and plr.TeamColor ~= myTeamColor and plr.Character then
            
            local hum = plr.Character:FindFirstChild("Humanoid")
            local head = plr.Character:FindFirstChild("Head")
            local backpack = plr:FindFirstChildOfClass("Backpack")
            local hasBlade = plr.Character:FindFirstChild("Blade") 
                           or (backpack and backpack:FindFirstChild("Blade"))

            if hum and hum.Health > 0 and head and hasBlade then
                -- SAME EXACT DISTANCE LOGIC AS YOUR THROW SYSTEM
                local dist = (head.Position - Camera.CFrame.Position).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    closestPart = plr -- return PLAYER (your killfunc uses player)
                end
            end
        end
    end

    return closestPart
end

-- local function GetSkid()
--     local myTeamColor = lp.TeamColor
--
--     for _, plr in pairs(plrs:GetPlayers()) do
--         if plr ~= lp and plr.Character then
--
--             -- TEAM EXCLUSION
--             if myTeamColor and plr.TeamColor and (plr.TeamColor == myTeamColor) then
--                 -- skip teammate
--             else
--                 -- BLADE CHECK (Character first → Backpack second)
--                 local character = plr.Character
--                 local backpack = plr:FindFirstChildOfClass("Backpack")
--
--                 local hasBlade =
--                     character:FindFirstChild("Blade")
--                     or (backpack and backpack:FindFirstChild("Blade"))
--
--                 local humanoid = character:FindFirstChild("Humanoid")
--
--                 if hasBlade and humanoid and humanoid.Health > 0 then
--                     return plr
--                 end
--             end
--         end
--     end
--
--     return nil
-- end

local function computePassThrough(targetHRP)
    local rootCF = targetHRP.CFrame
    local forward = rootCF.LookVector
    local behind = rootCF.Position + forward * 6  -- knife exits behind them
    return behind
end

local function spawnGhostKnife(startPos, targetPos)
    local originalKnife = lp.Character and lp.Character:FindFirstChild("Blade")
    if not originalKnife then return end

    local knifeClone = Instance.new("Part")
    knifeClone.Size = originalKnife.Size
    knifeClone.CFrame = CFrame.new(startPos, targetPos)
    knifeClone.Anchored = false
    knifeClone.CanCollide = false
    knifeClone.Material = originalKnife.Material
    knifeClone.Color = originalKnife.Color
    knifeClone.Parent = workspace

    -- Clone mesh if it exists
    local mesh = originalKnife:FindFirstChildOfClass("SpecialMesh")
    if mesh then mesh:Clone().Parent = knifeClone end

    local dir = (targetPos - startPos).Unit
    knifeClone.AssemblyLinearVelocity = dir * 260

    -- Random spin
    local bg = Instance.new("BodyGyro")
    bg.CFrame = knifeClone.CFrame
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.P = 1e4
    bg.D = 0
    bg.Parent = knifeClone

    -- Random angular velocity for spin
    local randomSpin = Vector3.new(
        math.random(-360, 360),
        math.random(-360, 360),
        math.random(-360, 360)
    )
    knifeClone.AssemblyAngularVelocity = randomSpin

    -- Blood particle on hit
    knifeClone.Touched:Connect(function(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local blood = Instance.new("ParticleEmitter")
            blood.Texture = "rbxassetid://241594314"  -- Roblox blood texture
            blood.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
            blood.Lifetime = NumberRange.new(0.3, 0.6)
            blood.Rate = 50
            blood.Speed = NumberRange.new(5, 15)
            blood.VelocitySpread = 180
            blood.Parent = hit
            game:GetService("Debris"):AddItem(blood, 0.5)
        end
    end)

    game:GetService("Debris"):AddItem(knifeClone, 3)
end

            ------------------------------------------------------------------
            -- ULTRA-STABLE KILLFUNC SYSTEM (AUTO RECOVERY)
            ------------------------------------------------------------------
            local lastStatus = nil
            local KillFunc = nil
            local killSignatureFound = nil
            local lastKillFuncPointer = nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc = nil
                killSignatureFound = nil
                lastKillFuncPointer = nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then
                        killSignatureFound = 1
                        Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then
                        killSignatureFound = 2
                        Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5})
                    end
                    return true
                end

                if safe(KillFunc, part, true) then
                    if not killSignatureFound then
                        killSignatureFound = 3
                        Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5})
                    end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- R6 BODY PART CYCLE (F MODE)
            ------------------------------------------------------------------
            local cycleIndex = 1
            local cycleOrder = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}

            local function GetNextR6Part(character)
                for i = 1, 6 do
                    local partName = cycleOrder[cycleIndex]
                    cycleIndex = cycleIndex % 6 + 1
                    local part = character:FindFirstChild(partName)
                    if part then return part end
                end
                return character:FindFirstChild("HumanoidRootPart")
            end

            ------------------------------------------------------------------
            -- WATCHDOG
            ------------------------------------------------------------------
            task.spawn(function()
                while duoAlwaysHit3Active do
                    if not KillFunc then FindKillFunc() end
                    RunService.Heartbeat:Wait()
                end
            end)

            ------------------------------------------------------------------
            -- MAIN LOOP (CYCLING BODY PARTS) DYNAMIC FPS
            ------------------------------------------------------------------
            task.spawn(function()
                local attemptAccumulator = 0
                local BASE_INTERVAL = 0.05   -- base interval ~20 FPS

                RunService.Heartbeat:Connect(function(deltaTime)
                    if not duoAlwaysHit3Active then return end

                    local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                    attemptAccumulator = attemptAccumulator + deltaTime
                    if attemptAccumulator < interval then return end
                    attemptAccumulator = 0

                    if duoHitbox2Active then
                        local target = GetSkid()
                        if target and target.Character then
                            local part = GetNextR6Part(target.Character)
                            if part then
                                safe(function()
                                    local ok = TryKill(part)

if ok then
    -- Only spawn ghost knife WHEN the kill actually succeeds
    local startPos = lp.Character.Blade.Position
    local finalPos = computePassThrough(part)

    spawnGhostKnife(startPos, finalPos)
else
    -- fallback (same as yours)
    safe(KillFunc, part, true, part.Position)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
},

-- // hit body toggle  --

["Legit Auto Throw"] = {
    button = extraButton,
    state = false,
    toggleFunction = function(state)
        hitbox2Active = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")
        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function GetMsgBoxFunc()
            for _, v in pairs(getgc(true)) do
                if type(v) == "function" and debug.getinfo(v).name == "fancymsgbox" then
                    MsgBox = v
                    break
                end
            end
        end

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.20, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
-- PERFECTLY STABLE CROSSHAIR + AIMLOCK (NO PREDICTION)
----------------------------------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local lp = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local crosshairPart
local crosshairPos
local bestTargetForAimlock
local trackConn

----------------------------------------------------
-- SCREEN CROSSHAIR (VISIBLE ALWAYS)
----------------------------------------------------
local screenGui
local crosshairImg

local function ensureCrosshairVisual()
    if not crosshairPart or not crosshairPart.Parent then
        local p = Instance.new("Part")
        p.Anchored = true
        p.CanCollide = false
        p.Size = Vector3.new(0.1, 0.1, 0.1)
        p.Transparency = 1
        p.Parent = Workspace
        crosshairPart = p
    end

    if screenGui then return end

    local pg = lp:WaitForChild("PlayerGui")
    task.wait(0)

    screenGui = Instance.new("ScreenGui")
    screenGui.IgnoreGuiInset = true
    screenGui.ResetOnSpawn = false
    screenGui.DisplayOrder = 999999
    screenGui.Parent = pg

    crosshairImg = Instance.new("ImageLabel")
    crosshairImg.AnchorPoint = Vector2.new(0.5, 0.5)
    crosshairImg.BackgroundTransparency = 1
    crosshairImg.Visible = true

    crosshairImg.Image = "rbxassetid://7072718365" -- your test decal
    crosshairImg.Size = UDim2.new(0, 60, 0, 60)
    crosshairImg.Parent = screenGui
end

local function stopCrosshairTracking()
    if trackConn then trackConn:Disconnect() end
    trackConn = nil

    if crosshairPart then crosshairPart:Destroy() end
    crosshairPart = nil

    if screenGui then screenGui:Destroy() end
    screenGui = nil
    crosshairImg = nil

    crosshairPos = nil
    bestTargetForAimlock = nil
end

----------------------------------------------------
-- VISUAL ORBIT/BACK OFFSET
----------------------------------------------------
local orbitRadius = 1.25
local orbitSpeed  = 2.75
local verticalBob = 0.35
local verticalAmp = 0.15
local backOffsetDist = 7

-- R6 head-level
local verticalAimOffset = Vector3.new(0, 1, 0)

----------------------------------------------------
-- START LOCK (NO PREDICTION AT ALL)
----------------------------------------------------
local function startLock()
    ensureCrosshairVisual()

    if trackConn then trackConn:Disconnect() end

    trackConn = RunService.RenderStepped:Connect(function()
        local t = bestTargetForAimlock
        if not t or not t.Parent then
            stopCrosshairTracking()
            return
        end

        local hum = t.Parent:FindFirstChild("Humanoid")
        if hum and hum.Health <= 0 then
            stopCrosshairTracking()
            ensureCrosshairVisual()
            return
        end

        local root = t.Parent:FindFirstChild("HumanoidRootPart") or t.Parent:FindFirstChild("Torso")
        if not root then return end

        ----------------------------------------------------
        -- ORBIT OFFSET (PURE VISUAL, NEVER PREDICTIVE)
        ----------------------------------------------------
        local tnow = os.clock()

        local orbitX = math.cos(tnow * orbitSpeed) * orbitRadius
        local orbitZ = math.sin(tnow * orbitSpeed) * orbitRadius
        local orbitY = math.sin(tnow * verticalBob) * verticalAmp

        local orbitOffset = Vector3.new(orbitX, orbitY, orbitZ)

        ----------------------------------------------------
        -- 🔥 FINAL EXACT REAL-TIME POSITION (NO PREDICTION)
        ----------------------------------------------------
        local finalVisualPos = root.Position + verticalAimOffset + orbitOffset
        crosshairPos = finalVisualPos

        ----------------------------------------------------
        -- 2D UI CROSSHAIR
        ----------------------------------------------------
        if crosshairImg then
            local screenPos, onScreen = Camera:WorldToViewportPoint(finalVisualPos)
            crosshairImg.Visible = onScreen
            if onScreen then
                crosshairImg.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
            end
        end

        ----------------------------------------------------
        -- 3D PART BEHIND TARGET (NO PREDICTION)
        ----------------------------------------------------
        if crosshairPart then
            local camDir = (Camera.CFrame.Position - finalVisualPos).Unit
            crosshairPart.Position = finalVisualPos - camDir * backOffsetDist
        end
    end)
end

----------------------------------------------------
-- VISUAL GHOST KNIFE SYSTEM (ALSO NO PREDICTION)
----------------------------------------------------
local VISUAL_KNIFE_SPEED = 270
local verticalOffset = Vector3.new(0, 1, 0)

local activeVisualKnives = {}

local function getKnifeAppearance()
    if not lp.Character then return nil end
    local blade = lp.Character:FindFirstChild("Blade")
    if not blade then return nil end

    local clone = blade:Clone()
    clone.Anchored = true
    clone.CanCollide = false
    clone.Parent = Workspace
    return clone
end

local function spawnGhostKnife(startPos, targetPos)
    local knife = getKnifeAppearance()
    if not knife then return end

    startPos = startPos + verticalOffset
    targetPos = targetPos + verticalOffset

    local dir = (targetPos - startPos).Unit
    local distance = (targetPos - startPos).Magnitude

    knife.CFrame = CFrame.new(startPos, targetPos)

    table.insert(activeVisualKnives, {
        Part = knife,
        StartPos = startPos,
        TargetPos = targetPos,
        Dir = dir,
        Distance = distance,
        Travelled = 0,
        TimeAlive = 0
    })
end

RunService.RenderStepped:Connect(function(dt)
    for i = #activeVisualKnives, 1, -1 do
        local k = activeVisualKnives[i]
        if not k.Part or not k.Part.Parent then
            table.remove(activeVisualKnives, i)
        else
            local moveDelta = k.Dir * VISUAL_KNIFE_SPEED * dt
            k.Travelled += moveDelta.Magnitude

            if k.Travelled >= k.Distance then
                k.Part.CFrame = CFrame.new(k.TargetPos, k.TargetPos + k.Dir)
                k.Part:Destroy()
                table.remove(activeVisualKnives, i)
            else
                k.Part.CFrame = CFrame.new(
                    k.StartPos + k.Dir * k.Travelled,
                    k.StartPos + k.Dir * k.Travelled + k.Dir
                )
            end

            k.TimeAlive += dt
        end
    end
end)

----------------------------------------------------
-- FIRE KNIFE (NO PING, NO PREDICTION)
----------------------------------------------------
local function fireKnife(bind)
    if not bind or not crosshairPart then return end
    if not crosshairPos then return end

    local finalVisualPos = crosshairPos  -- EXACT RAW POSITION

    -- Send exact position to server
    pcall(function()
        bind:Fire("t", CFrame.new(finalVisualPos))
    end)

    -- Visual ghost knife
    if lp.Character and lp.Character:FindFirstChild("Blade") then
        spawnGhostKnife(lp.Character.Blade.Position, finalVisualPos)
    end
end

        ----------------------------------------------------
        -- MONITOR LOCAL PLAYER DEATH
        ----------------------------------------------------
        task.spawn(function()
            while true do
                task.wait()
                if not lp.Character then
                    stopCrosshairTracking()
                    continue
                end
                local hum = lp.Character:FindFirstChild("Humanoid")
                if hum and hum.Health <= 0 then
                    stopCrosshairTracking()
                end
            end
        end)

        ----------------------------------------------------
        -- WHEN CHARACTER RESPAWNS
        ----------------------------------------------------
        lp.CharacterAdded:Connect(function(newChar)
              if hitbox2Active then
                  task.wait(0)
                stopCrosshairTracking()
            end
        end)

        ----------------------------------------------------
        -- MONITOR LOCAL PLAYER DEATH
        ----------------------------------------------------
        -- local function monitorLocalDeath()
        --    task.spawn(function()
        --        while true do
        --            task.wait()
        --            if not lp.Character then
        --                stopCrosshairTracking()
        --                continue
        --            end
        --            local hum = lp.Character:FindFirstChild("Humanoid")
        --            if hum and hum.Health <= 0 then
        --                stopCrosshairTracking()
        --            end
        --        end
        --    end)
        -- end
        -- monitorLocalDeath()

        --------------------------------------------------------------------
        -- MAIN AUTO-THROW LOOP
        --------------------------------------------------------------------
        task.spawn(function()
            GetMsgBoxFunc()
            if MsgBox then MsgBox("Legit Auto-throw loaded! Very very good aiming") end
            while hitbox2Active do
                startLock() -- begin live smooth tracking
                task.wait()

                if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
                if lp.Character.Humanoid.Health <= 0 then continue end
                if not hasToolEquipped() then continue end

                bind = lp.PlayerScripts:FindFirstChild("Event") or bind
                if not bind then continue end

                local camera = Workspace.CurrentCamera
                local bestTarget, bestDist = nil, math.huge

                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local hum = plr.Character:FindFirstChild("Humanoid")
                        local head = plr.Character:FindFirstChild("Head")
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                        if hum and hum.Health > 0 and head and hasBlade then
                            local dist = (head.Position - camera.CFrame.Position).Magnitude
                            if dist < bestDist then
                                bestTarget, bestDist = head, dist
                            end
                        end
                    end
                end

                if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
                    lastThrowTime = tick()
                    bestTargetForAimlock = bestTarget

                    -- synced animation delay
                    task.delay(0, function()
                        if not hitbox2Active then return end
                        playThrowAnimation()
                        task.wait(0.2)
                        fireKnife(bind)
                    end)
                end
            end
        end)
    end
},

["Legit Auto Throw (Duos)"] = {
    button = extra2Button,
    state = false,
    toggleFunction = function(state)
        duoHitbox2Active = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")
        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw Duos",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function GetMsgBoxFunc()
            for _, v in pairs(getgc(true)) do
                if type(v) == "function" and debug.getinfo(v).name == "fancymsgbox" then
                    MsgBox = v
                    break
                end
            end
        end

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.20, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
-- PERFECTLY STABLE CROSSHAIR + AIMLOCK (NO PREDICTION)
----------------------------------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local lp = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local crosshairPart
local crosshairPos
local bestTargetForAimlock
local trackConn

----------------------------------------------------
-- SCREEN CROSSHAIR (VISIBLE ALWAYS)
----------------------------------------------------
local screenGui
local crosshairImg

local function ensureCrosshairVisual()
    if not crosshairPart or not crosshairPart.Parent then
        local p = Instance.new("Part")
        p.Anchored = true
        p.CanCollide = false
        p.Size = Vector3.new(0.1, 0.1, 0.1)
        p.Transparency = 1
        p.Parent = Workspace
        crosshairPart = p
    end

    if screenGui then return end

    local pg = lp:WaitForChild("PlayerGui")
    task.wait(0)

    screenGui = Instance.new("ScreenGui")
    screenGui.IgnoreGuiInset = true
    screenGui.ResetOnSpawn = false
    screenGui.DisplayOrder = 999999
    screenGui.Parent = pg

    crosshairImg = Instance.new("ImageLabel")
    crosshairImg.AnchorPoint = Vector2.new(0.5, 0.5)
    crosshairImg.BackgroundTransparency = 1
    crosshairImg.Visible = true

    crosshairImg.Image = "rbxassetid://7072718365" -- your test decal
    crosshairImg.Size = UDim2.new(0, 60, 0, 60)
    crosshairImg.Parent = screenGui
end

local function stopCrosshairTracking()
    if trackConn then trackConn:Disconnect() end
    trackConn = nil

    if crosshairPart then crosshairPart:Destroy() end
    crosshairPart = nil

    if screenGui then screenGui:Destroy() end
    screenGui = nil
    crosshairImg = nil

    crosshairPos = nil
    bestTargetForAimlock = nil
end

----------------------------------------------------
-- VISUAL ORBIT/BACK OFFSET
----------------------------------------------------
local orbitRadius = 1.25
local orbitSpeed  = 2.75
local verticalBob = 0.35
local verticalAmp = 0.15
local backOffsetDist = 7

-- R6 head-level
local verticalAimOffset = Vector3.new(0, 1, 0)

----------------------------------------------------
-- START LOCK (NO PREDICTION AT ALL)
----------------------------------------------------
local function startLock()
    ensureCrosshairVisual()

    if trackConn then trackConn:Disconnect() end

    trackConn = RunService.RenderStepped:Connect(function()
        local t = bestTargetForAimlock
        if not t or not t.Parent then
            stopCrosshairTracking()
            return
        end

        local hum = t.Parent:FindFirstChild("Humanoid")
        if hum and hum.Health <= 0 then
            stopCrosshairTracking()
            ensureCrosshairVisual()
            return
        end

        local root = t.Parent:FindFirstChild("HumanoidRootPart") or t.Parent:FindFirstChild("Torso")
        if not root then return end

        ----------------------------------------------------
        -- ORBIT OFFSET (PURE VISUAL, NEVER PREDICTIVE)
        ----------------------------------------------------
        local tnow = os.clock()

        local orbitX = math.cos(tnow * orbitSpeed) * orbitRadius
        local orbitZ = math.sin(tnow * orbitSpeed) * orbitRadius
        local orbitY = math.sin(tnow * verticalBob) * verticalAmp

        local orbitOffset = Vector3.new(orbitX, orbitY, orbitZ)

        ----------------------------------------------------
        -- 🔥 FINAL EXACT REAL-TIME POSITION (NO PREDICTION)
        ----------------------------------------------------
        local finalVisualPos = root.Position + verticalAimOffset + orbitOffset
        crosshairPos = finalVisualPos

        ----------------------------------------------------
        -- 2D UI CROSSHAIR
        ----------------------------------------------------
        if crosshairImg then
            local screenPos, onScreen = Camera:WorldToViewportPoint(finalVisualPos)
            crosshairImg.Visible = onScreen
            if onScreen then
                crosshairImg.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
            end
        end

        ----------------------------------------------------
        -- 3D PART BEHIND TARGET (NO PREDICTION)
        ----------------------------------------------------
        if crosshairPart then
            local camDir = (Camera.CFrame.Position - finalVisualPos).Unit
            crosshairPart.Position = finalVisualPos - camDir * backOffsetDist
        end
    end)
end

----------------------------------------------------
-- VISUAL GHOST KNIFE SYSTEM (ALSO NO PREDICTION)
----------------------------------------------------
local VISUAL_KNIFE_SPEED = 270
local verticalOffset = Vector3.new(0, 1, 0)

local activeVisualKnives = {}

local function getKnifeAppearance()
    if not lp.Character then return nil end
    local blade = lp.Character:FindFirstChild("Blade")
    if not blade then return nil end

    local clone = blade:Clone()
    clone.Anchored = true
    clone.CanCollide = false
    clone.Parent = Workspace
    return clone
end

local function spawnGhostKnife(startPos, targetPos)
    local knife = getKnifeAppearance()
    if not knife then return end

    startPos = startPos + verticalOffset
    targetPos = targetPos + verticalOffset

    local dir = (targetPos - startPos).Unit
    local distance = (targetPos - startPos).Magnitude

    knife.CFrame = CFrame.new(startPos, targetPos)

    table.insert(activeVisualKnives, {
        Part = knife,
        StartPos = startPos,
        TargetPos = targetPos,
        Dir = dir,
        Distance = distance,
        Travelled = 0,
        TimeAlive = 0
    })
end

RunService.RenderStepped:Connect(function(dt)
    for i = #activeVisualKnives, 1, -1 do
        local k = activeVisualKnives[i]
        if not k.Part or not k.Part.Parent then
            table.remove(activeVisualKnives, i)
        else
            local moveDelta = k.Dir * VISUAL_KNIFE_SPEED * dt
            k.Travelled += moveDelta.Magnitude

            if k.Travelled >= k.Distance then
                k.Part.CFrame = CFrame.new(k.TargetPos, k.TargetPos + k.Dir)
                k.Part:Destroy()
                table.remove(activeVisualKnives, i)
            else
                k.Part.CFrame = CFrame.new(
                    k.StartPos + k.Dir * k.Travelled,
                    k.StartPos + k.Dir * k.Travelled + k.Dir
                )
            end

            k.TimeAlive += dt
        end
    end
end)

----------------------------------------------------
-- FIRE KNIFE (NO PING, NO PREDICTION)
----------------------------------------------------
local function fireKnife(bind)
    if not bind or not crosshairPart then return end
    if not crosshairPos then return end

    local finalVisualPos = crosshairPos  -- EXACT RAW POSITION

    -- Send exact position to server
    pcall(function()
        bind:Fire("t", CFrame.new(finalVisualPos))
    end)

    -- Visual ghost knife
    if lp.Character and lp.Character:FindFirstChild("Blade") then
        spawnGhostKnife(lp.Character.Blade.Position, finalVisualPos)
    end
end

        ----------------------------------------------------
        -- MONITOR LOCAL PLAYER DEATH
        ----------------------------------------------------
        task.spawn(function()
            while true do
                task.wait()
                if not lp.Character then
                    stopCrosshairTracking()
                    continue
                end
                local hum = lp.Character:FindFirstChild("Humanoid")
                if hum and hum.Health <= 0 then
                    stopCrosshairTracking()
                end
            end
        end)

        ----------------------------------------------------
        -- WHEN CHARACTER RESPAWNS
        ----------------------------------------------------
        lp.CharacterAdded:Connect(function(newChar)
              if duoHitbox2Active then
                  task.wait(0)
                stopCrosshairTracking()
            end
        end)

        ----------------------------------------------------
        -- MONITOR LOCAL PLAYER DEATH
        ----------------------------------------------------
        -- local function monitorLocalDeath()
        --    task.spawn(function()
        --        while true do
        --            task.wait()
        --            if not lp.Character then
        --                stopCrosshairTracking()
        --                continue
        --            end
        --            local hum = lp.Character:FindFirstChild("Humanoid")
        --            if hum and hum.Health <= 0 then
        --                stopCrosshairTracking()
        --            end
        --        end
        --    end)
        -- end
        -- monitorLocalDeath()

        --------------------------------------------------------------------
        -- MAIN AUTO-THROW LOOP
        --------------------------------------------------------------------
task.spawn(function()
    GetMsgBoxFunc()
    if MsgBox then MsgBox("Legit Auto-throw Duos edition loaded! Very very good aiming") end

    while duoHitbox2Active do
        startLock() -- update visual crosshair

        task.wait() -- tiny yield to prevent freezing

        -- Skip if character or tool isn’t ready
        if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
        if lp.Character.Humanoid.Health <= 0 then continue end
        if not hasToolEquipped() then continue end

        bind = lp.PlayerScripts:FindFirstChild("Event") or bind
        if not bind then continue end

        -- Find the **closest enemy alive with a blade**
        local camera = Workspace.CurrentCamera
        local bestTarget, bestDist = nil, math.huge
        local localTeamColor = lp.TeamColor

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
                local hum = plr.Character:FindFirstChild("Humanoid")
                local head = plr.Character:FindFirstChild("Head")
                local backpack = plr:FindFirstChildOfClass("Backpack")
                local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                if hum and hum.Health > 0 and head and hasBlade then
                    local dist = (head.Position - camera.CFrame.Position).Magnitude
                    if dist < bestDist then
                        bestTarget, bestDist = head, dist
                    end
                end
            end
        end

        -- Only throw if a valid target exists and cooldown passed
        if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
            lastThrowTime = tick()
            bestTargetForAimlock = bestTarget

            -- Throw synced with animation
            task.spawn(function()
                if not duoHitbox2Active then return end
                playThrowAnimation()
                local throwDelay = 0.2
                local elapsed = 0

                -- **Dynamic mid-delay target update**
                while elapsed < throwDelay do
                    local dt = RunService.Heartbeat:Wait()
                    elapsed = elapsed + dt

                    -- constantly pick closest enemy during the animation
                    local currentBest, currentDist = nil, math.huge
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
                            local hum = plr.Character:FindFirstChild("Humanoid")
                            local head = plr.Character:FindFirstChild("Head")
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                            if hum and hum.Health > 0 and head and hasBlade then
                                local dist = (head.Position - camera.CFrame.Position).Magnitude
                                if dist < currentDist then
                                    currentBest, currentDist = head, dist
                                end
                            end
                        end
                    end
                    bestTargetForAimlock = currentBest -- dynamically switch target
                end

                fireKnife(bind)
                    end)
                end
            end
        end)
    end
},

["Legit Auto Throw Duos V2"] = {
    button = duoHit1Button,
    state = false,
    toggleFunction = function(state)
        duoHitbox1Active = state
        duoHit1Active = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")

        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw Duos",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.25, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
        -- CROSSHAIR AND AIMLOCK LOGIC
        ----------------------------------------------------
        local function ensureCrosshairVisual()
            if crosshairPart and crosshairPart.Parent then return end
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.Shape = Enum.PartType.Ball
            p.Material = Enum.Material.Neon
            p.Color = Color3.new(1,0,0)
            p.Size = Vector3.new(0.35,0.35,0.35)
            p.Parent = workspace
            crosshairPart = p

            if bestTargetForAimlock then
                local raw = bestTargetForAimlock.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    crosshairPos = crosshairPos:Lerp(raw, 0.35)
                end
                crosshairPart.Position = crosshairPos
            end
        end

        local function stopCrosshairTracking()
            if trackConn then
                trackConn:Disconnect()
                trackConn = nil
            end
            if crosshairPart then
                crosshairPart:Destroy()
                crosshairPart = nil
            end
            crosshairPos = nil
            bestTargetForAimlock = nil
        end

        local function startLock()
            ensureCrosshairVisual()
            if trackConn then trackConn:Disconnect() end

            trackConn = RunService.RenderStepped:Connect(function()
                local t = bestTargetForAimlock
                if not t or not t.Parent then
                    stopCrosshairTracking()
                    return
                end

                local targetHum = t.Parent:FindFirstChild("Humanoid")
                if targetHum and targetHum.Health <= 0 then
                    stopCrosshairTracking()
                    ensureCrosshairVisual()
                    return
                end

                local raw = t.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    local delta = (raw - crosshairPos).Magnitude
                    if delta > 1 then
                        crosshairPos = raw
                    else
                        crosshairPos = crosshairPos:Lerp(raw, 0.35)
                    end
                end

                if crosshairPart then
                    crosshairPart.Transparency = 0
                    crosshairPart.Position = crosshairPos
                end
            end)
        end

        local function fireKnife(bind)
            if not bind or not crosshairPart then return end
            local aimPos = crosshairPos
            if aimPos then
                pcall(function()
                    bind:Fire("t", CFrame.new(aimPos)) -- ORIGINAL THROW
                end)
            end
        end

        ----------------------------------------------------
        -- ULTRA-STABLE KILLFUNC SYSTEM
        ----------------------------------------------------
        local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer

        local function Notify(t)
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = t.Title or "Status",
                    Text = t.Text or "",
                    Duration = t.Duration or 5
                })
            end)
        end

        local function HardRescan()
            KillFunc = nil
            killSignatureFound = nil
            lastKillFuncPointer = nil
        end

        local function FindKillFunc()
            for _, v in pairs(getgc(false)) do
                if type(v) == "function" then
                    local ok, env = pcall(getfenv, v)
                    if ok and env then
                        local scr = env.script
                        local firstScript = lp.PlayerScripts:GetChildren()[1]
                        local firstScriptName = firstScript and firstScript.Name or ""

                        if scr and tostring(scr) == firstScriptName then
                            local constants = debug.getconstants(v)
                            for _, c in pairs(constants) do
                                if tostring(c) == "IIlIla" then
                                    if v ~= lastKillFuncPointer then
                                        killSignatureFound = nil
                                        lastKillFuncPointer = v
                                    end

                                    KillFunc = v

                                    if lastStatus ~= "found" then
                                        lastStatus = "found"
                                        Notify({
                                            Title = "KillFunc Status",
                                            Text = "KillFunc FOUND ✔",
                                            Duration = 6
                                        })
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
            end

            if lastStatus ~= "notfound" then
                lastStatus = "notfound"
                Notify({
                    Title = "KillFunc Status",
                    Text = "KillFunc NOT FOUND ❌ — rescanning...",
                    Duration = 6
                })
            end
            return false
        end

        local function safe(fn, ...)
            return pcall(fn, ...)
        end

        local function GetSkid()
local myTeamColor = lp.TeamColor
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
-- Exclude any player whose TeamColor equals your local player's.
if myTeamColor and plr.TeamColor and (plr.TeamColor == myTeamColor) then
-- This is your teammate; skip.
else
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
return plr
end
end
end
end
return nil
end

        local function TryKillWithoutDestroy(part)
            if not KillFunc then return false end
            local success = false

            if killSignatureFound == 1 then
                success = safe(KillFunc, part, true, part.Position)
            elseif killSignatureFound == 2 then
                success = safe(KillFunc, part, part.Position, true)
            elseif killSignatureFound == 3 then
                success = safe(KillFunc, part, true)
            else
                if safe(KillFunc, part, true, part.Position) then
                    killSignatureFound = 1
                    success = true
                elseif safe(KillFunc, part, part.Position, true) then
                    killSignatureFound = 2
                    success = true
                elseif safe(KillFunc, part, true) then
                    killSignatureFound = 3
                    success = true
                end
            end
            return success
        end

        ------------------------------------------------------------------
        -- WATCHDOG
        ------------------------------------------------------------------
        task.spawn(function()
            while duoHit1Active do
                if not KillFunc then
                    FindKillFunc()
                end
                RunService.Heartbeat:Wait()
            end
        end)

        ------------------------------------------------------------------
        -- MAIN LOOP (HIT REGISTER)
        ------------------------------------------------------------------
        task.spawn(function()
            local attemptAccumulator = 0
            local BASE_INTERVAL = 0.05

            RunService.Heartbeat:Connect(function(deltaTime)
                if not duoHit1Active then return end
                local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                attemptAccumulator = attemptAccumulator + deltaTime
                if attemptAccumulator < interval then return end
                attemptAccumulator = 0

                if duoHitbox1Active then
                    local target = GetSkid()
                    if target and target.Character then
                        local part = target.Character:FindFirstChild("HumanoidRootPart")
                        if part then
                            TryKillWithoutDestroy(part)
                        end
                    end
                end
            end)
        end)

        ------------------------------------------------------------------
        -- AUTO-THROW LOOP
        ------------------------------------------------------------------
        task.spawn(function()
            while duoHitbox1Active do
                task.wait()
                if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
                if lp.Character.Humanoid.Health <= 0 then continue end
                if not hasToolEquipped() then continue end

                bind = lp.PlayerScripts:FindFirstChild("Event") or bind
                if not bind then continue end

                local camera = Workspace.CurrentCamera
                local bestTarget, bestDist = nil, math.huge
                local localTeamColor = lp.TeamColor

                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
                        local hum = plr.Character:FindFirstChild("Humanoid")
                        local head = plr.Character:FindFirstChild("Head")
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                        if hum and hum.Health > 0 and head and hasBlade then
                            local dist = (head.Position - camera.CFrame.Position).Magnitude
                            if dist < bestDist then
                                bestTarget, bestDist = head, dist
                            end
                        end
                    end
                end

                if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
                    lastThrowTime = tick()
                    bestTargetForAimlock = bestTarget

                    startLock()
                    pcall(FindKillFunc)

                    task.delay(0, function()
                        if not duoHitbox1Active then return end
                        playThrowAnimation()
                        playThrowAnimation()
                        RunService.RenderStepped:Wait()
                        task.wait(0.25)
                        startLock()
                        fireKnife(bind)

                        -- detached kill check
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("HumanoidRootPart")
                            if part then
                                TryKillWithoutDestroy(part)
                            end
                        end
                    end)
                end
            end
        end)
    end
},

["Legit Auto Throw Duos V2 (Head)"] = {
    button = duoHit2Button,
    state = false,
    toggleFunction = function(state)
        duoHitbox2Active = state
        duoHit2Active = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")

        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw Duos",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.25, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
        -- CROSSHAIR AND AIMLOCK LOGIC
        ----------------------------------------------------
        local function ensureCrosshairVisual()
            if crosshairPart and crosshairPart.Parent then return end
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.Shape = Enum.PartType.Ball
            p.Material = Enum.Material.Neon
            p.Color = Color3.new(1,0,0)
            p.Size = Vector3.new(0.35,0.35,0.35)
            p.Parent = workspace
            crosshairPart = p

            if bestTargetForAimlock then
                local raw = bestTargetForAimlock.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    crosshairPos = crosshairPos:Lerp(raw, 0.35)
                end
                crosshairPart.Position = crosshairPos
            end
        end

        local function stopCrosshairTracking()
            if trackConn then
                trackConn:Disconnect()
                trackConn = nil
            end
            if crosshairPart then
                crosshairPart:Destroy()
                crosshairPart = nil
            end
            crosshairPos = nil
            bestTargetForAimlock = nil
        end

        local function startLock()
            ensureCrosshairVisual()
            if trackConn then trackConn:Disconnect() end

            trackConn = RunService.RenderStepped:Connect(function()
                local t = bestTargetForAimlock
                if not t or not t.Parent then
                    stopCrosshairTracking()
                    return
                end

                local targetHum = t.Parent:FindFirstChild("Humanoid")
                if targetHum and targetHum.Health <= 0 then
                    stopCrosshairTracking()
                    ensureCrosshairVisual()
                    return
                end

                local raw = t.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    local delta = (raw - crosshairPos).Magnitude
                    if delta > 1 then
                        crosshairPos = raw
                    else
                        crosshairPos = crosshairPos:Lerp(raw, 0.35)
                    end
                end

                if crosshairPart then
                    crosshairPart.Transparency = 0
                    crosshairPart.Position = crosshairPos
                end
            end)
        end

        local function fireKnife(bind)
            if not bind or not crosshairPart then return end
            local aimPos = crosshairPos
            if aimPos then
                pcall(function()
                    bind:Fire("t", CFrame.new(aimPos)) -- ORIGINAL THROW
                end)
            end
        end

        ----------------------------------------------------
        -- ULTRA-STABLE KILLFUNC SYSTEM
        ----------------------------------------------------
        local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer

        local function Notify(t)
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = t.Title or "Status",
                    Text = t.Text or "",
                    Duration = t.Duration or 5
                })
            end)
        end

        local function HardRescan()
            KillFunc = nil
            killSignatureFound = nil
            lastKillFuncPointer = nil
        end

        local function FindKillFunc()
            for _, v in pairs(getgc(false)) do
                if type(v) == "function" then
                    local ok, env = pcall(getfenv, v)
                    if ok and env then
                        local scr = env.script
                        local firstScript = lp.PlayerScripts:GetChildren()[1]
                        local firstScriptName = firstScript and firstScript.Name or ""

                        if scr and tostring(scr) == firstScriptName then
                            local constants = debug.getconstants(v)
                            for _, c in pairs(constants) do
                                if tostring(c) == "IIlIla" then
                                    if v ~= lastKillFuncPointer then
                                        killSignatureFound = nil
                                        lastKillFuncPointer = v
                                    end

                                    KillFunc = v

                                    if lastStatus ~= "found" then
                                        lastStatus = "found"
                                        Notify({
                                            Title = "KillFunc Status",
                                            Text = "KillFunc FOUND ✔",
                                            Duration = 6
                                        })
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
            end

            if lastStatus ~= "notfound" then
                lastStatus = "notfound"
                Notify({
                    Title = "KillFunc Status",
                    Text = "KillFunc NOT FOUND ❌ — rescanning...",
                    Duration = 6
                })
            end
            return false
        end

        local function safe(fn, ...)
            return pcall(fn, ...)
        end

        local function GetSkid()
local myTeamColor = lp.TeamColor
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
-- Exclude any player whose TeamColor equals your local player's.
if myTeamColor and plr.TeamColor and (plr.TeamColor == myTeamColor) then
-- This is your teammate; skip.
else
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
return plr
end
end
end
end
return nil
end

        local function TryKillWithoutDestroy(part)
            if not KillFunc then return false end
            local success = false

            if killSignatureFound == 1 then
                success = safe(KillFunc, part, true, part.Position)
            elseif killSignatureFound == 2 then
                success = safe(KillFunc, part, part.Position, true)
            elseif killSignatureFound == 3 then
                success = safe(KillFunc, part, true)
            else
                if safe(KillFunc, part, true, part.Position) then
                    killSignatureFound = 1
                    success = true
                elseif safe(KillFunc, part, part.Position, true) then
                    killSignatureFound = 2
                    success = true
                elseif safe(KillFunc, part, true) then
                    killSignatureFound = 3
                    success = true
                end
            end
            return success
        end

        ------------------------------------------------------------------
        -- WATCHDOG
        ------------------------------------------------------------------
        task.spawn(function()
            while duoHit2Active do
                if not KillFunc then
                    FindKillFunc()
                end
                RunService.Heartbeat:Wait()
            end
        end)

        ------------------------------------------------------------------
        -- MAIN LOOP (HIT REGISTER)
        ------------------------------------------------------------------
        task.spawn(function()
            local attemptAccumulator = 0
            local BASE_INTERVAL = 0.05

            RunService.Heartbeat:Connect(function(deltaTime)
                if not duoHit2Active then return end
                local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                attemptAccumulator = attemptAccumulator + deltaTime
                if attemptAccumulator < interval then return end
                attemptAccumulator = 0

                if duoHitbox1Active then
                    local target = GetSkid()
                    if target and target.Character then
                        local part = target.Character:FindFirstChild("HumanoidRootPart")
                        if part then
                            TryKillWithoutDestroy(part)
                        end
                    end
                end
            end)
        end)

        ------------------------------------------------------------------
        -- AUTO-THROW LOOP
        ------------------------------------------------------------------
        task.spawn(function()
            while duoHitbox2Active do
                task.wait()
                if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
                if lp.Character.Humanoid.Health <= 0 then continue end
                if not hasToolEquipped() then continue end

                bind = lp.PlayerScripts:FindFirstChild("Event") or bind
                if not bind then continue end

                local camera = Workspace.CurrentCamera
                local bestTarget, bestDist = nil, math.huge
                local localTeamColor = lp.TeamColor

                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
                        local hum = plr.Character:FindFirstChild("Humanoid")
                        local head = plr.Character:FindFirstChild("Head")
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                        if hum and hum.Health > 0 and head and hasBlade then
                            local dist = (head.Position - camera.CFrame.Position).Magnitude
                            if dist < bestDist then
                                bestTarget, bestDist = head, dist
                            end
                        end
                    end
                end

                if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
                    lastThrowTime = tick()
                    bestTargetForAimlock = bestTarget

                    startLock()
                    pcall(FindKillFunc)

                    task.delay(0, function()
                        if not duoHitbox2Active then return end
                        playThrowAnimation()
                        playThrowAnimation()
                        RunService.RenderStepped:Wait()
                        task.wait(0.25)
                        startLock()
                        fireKnife(bind)

                        -- detached kill check
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("Head")
                            if part then
                                TryKillWithoutDestroy(part)
                            end
                        end
                    end)
                end
            end
        end)
    end
},

["Legit Auto Throw V2"] = {
    button = anotherButton,
    state = false,
    toggleFunction = function(state)
        boxActive = state
        alwaysHitActive = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")

        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.25, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
        -- CROSSHAIR AND AIMLOCK LOGIC
        ----------------------------------------------------
        local function ensureCrosshairVisual()
            if crosshairPart and crosshairPart.Parent then return end
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.Shape = Enum.PartType.Ball
            p.Material = Enum.Material.Neon
            p.Color = Color3.new(1,0,0)
            p.Size = Vector3.new(0.35,0.35,0.35)
            p.Parent = workspace
            crosshairPart = p

            if bestTargetForAimlock then
                local raw = bestTargetForAimlock.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    crosshairPos = crosshairPos:Lerp(raw, 0.35)
                end
                crosshairPart.Position = crosshairPos
            end
        end

        local function stopCrosshairTracking()
            if trackConn then
                trackConn:Disconnect()
                trackConn = nil
            end
            if crosshairPart then
                crosshairPart:Destroy()
                crosshairPart = nil
            end
            crosshairPos = nil
            bestTargetForAimlock = nil
        end

        local function startLock()
            ensureCrosshairVisual()
            if trackConn then trackConn:Disconnect() end

            trackConn = RunService.RenderStepped:Connect(function()
                local t = bestTargetForAimlock
                if not t or not t.Parent then
                    stopCrosshairTracking()
                    return
                end

                local targetHum = t.Parent:FindFirstChild("Humanoid")
                if targetHum and targetHum.Health <= 0 then
                    stopCrosshairTracking()
                    ensureCrosshairVisual()
                    return
                end

                local raw = t.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    local delta = (raw - crosshairPos).Magnitude
                    if delta > 1 then
                        crosshairPos = raw
                    else
                        crosshairPos = crosshairPos:Lerp(raw, 0.35)
                    end
                end

                if crosshairPart then
                    crosshairPart.Transparency = 0
                    crosshairPart.Position = crosshairPos
                end
            end)
        end

        local function fireKnife(bind)
            if not bind or not crosshairPart then return end
            local aimPos = crosshairPos
            if aimPos then
                pcall(function()
                    bind:Fire("t", CFrame.new(aimPos)) -- ORIGINAL THROW
                end)
            end
        end

        ----------------------------------------------------
        -- ULTRA-STABLE KILLFUNC SYSTEM
        ----------------------------------------------------
        local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer

        local function Notify(t)
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = t.Title or "Status",
                    Text = t.Text or "",
                    Duration = t.Duration or 5
                })
            end)
        end

        local function HardRescan()
            KillFunc = nil
            killSignatureFound = nil
            lastKillFuncPointer = nil
        end

        local function FindKillFunc()
            for _, v in pairs(getgc(false)) do
                if type(v) == "function" then
                    local ok, env = pcall(getfenv, v)
                    if ok and env then
                        local scr = env.script
                        local firstScript = lp.PlayerScripts:GetChildren()[1]
                        local firstScriptName = firstScript and firstScript.Name or ""

                        if scr and tostring(scr) == firstScriptName then
                            local constants = debug.getconstants(v)
                            for _, c in pairs(constants) do
                                if tostring(c) == "IIlIla" then
                                    if v ~= lastKillFuncPointer then
                                        killSignatureFound = nil
                                        lastKillFuncPointer = v
                                    end

                                    KillFunc = v

                                    if lastStatus ~= "found" then
                                        lastStatus = "found"
                                        Notify({
                                            Title = "KillFunc Status",
                                            Text = "KillFunc FOUND ✔",
                                            Duration = 6
                                        })
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
            end

            if lastStatus ~= "notfound" then
                lastStatus = "notfound"
                Notify({
                    Title = "KillFunc Status",
                    Text = "KillFunc NOT FOUND ❌ — rescanning...",
                    Duration = 6
                })
            end
            return false
        end

        local function safe(fn, ...)
            return pcall(fn, ...)
        end

        local function GetSkid()
            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= lp and plr.Character then
                    local backpack = plr:FindFirstChildOfClass("Backpack")
                    local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                    if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                        return plr
                    end
                end
            end
            return nil
        end

        local function TryKillWithoutDestroy(part)
            if not KillFunc then return false end
            local success = false

            if killSignatureFound == 1 then
                success = safe(KillFunc, part, true, part.Position)
            elseif killSignatureFound == 2 then
                success = safe(KillFunc, part, part.Position, true)
            elseif killSignatureFound == 3 then
                success = safe(KillFunc, part, true)
            else
                if safe(KillFunc, part, true, part.Position) then
                    killSignatureFound = 1
                    success = true
                elseif safe(KillFunc, part, part.Position, true) then
                    killSignatureFound = 2
                    success = true
                elseif safe(KillFunc, part, true) then
                    killSignatureFound = 3
                    success = true
                end
            end
            return success
        end

        ------------------------------------------------------------------
        -- WATCHDOG
        ------------------------------------------------------------------
        task.spawn(function()
            while alwaysHitActive do
                if not KillFunc then
                    FindKillFunc()
                end
                RunService.Heartbeat:Wait()
            end
        end)

        ------------------------------------------------------------------
        -- MAIN LOOP (HIT REGISTER)
        ------------------------------------------------------------------
        task.spawn(function()
            local attemptAccumulator = 0
            local BASE_INTERVAL = 0.05

            RunService.Heartbeat:Connect(function(deltaTime)
                if not alwaysHitActive then return end
                local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                attemptAccumulator = attemptAccumulator + deltaTime
                if attemptAccumulator < interval then return end
                attemptAccumulator = 0

                if boxActive then
                    local target = GetSkid()
                    if target and target.Character then
                        local part = target.Character:FindFirstChild("HumanoidRootPart")
                        if part then
                            TryKillWithoutDestroy(part)
                        end
                    end
                end
            end)
        end)

        ------------------------------------------------------------------
        -- AUTO-THROW LOOP
        ------------------------------------------------------------------
        task.spawn(function()
            while boxActive do
                task.wait()
                if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
                if lp.Character.Humanoid.Health <= 0 then continue end
                if not hasToolEquipped() then continue end

                bind = lp.PlayerScripts:FindFirstChild("Event") or bind
                if not bind then continue end

                local camera = Workspace.CurrentCamera
                local bestTarget, bestDist = nil, math.huge

                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local hum = plr.Character:FindFirstChild("Humanoid")
                        local head = plr.Character:FindFirstChild("Head")
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                        if hum and hum.Health > 0 and head and hasBlade then
                            local dist = (head.Position - camera.CFrame.Position).Magnitude
                            if dist < bestDist then
                                bestTarget, bestDist = head, dist
                            end
                        end
                    end
                end

                if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
                    lastThrowTime = tick()
                    bestTargetForAimlock = bestTarget

                    startLock()
                    pcall(FindKillFunc)

                    task.delay(0, function()
                        if not boxActive then return end
                        playThrowAnimation()
                        playThrowAnimation()
                        RunService.RenderStepped:Wait()
                        task.wait(0.25)
                        startLock()
                        fireKnife(bind)

                        -- detached kill check
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("HumanoidRootPart")
                            if part then
                                TryKillWithoutDestroy(part)
                            end
                        end
                    end)
                end
            end
        end)
    end
},

["Legit Auto Throw V2 (Head)"] = {
    button = headHitButton,
    state = false,
    toggleFunction = function(state)
        box2Active = state
        alwaysHit2Active = state

        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local StarterGui = game:GetService("StarterGui")

        local lp = Players.LocalPlayer
        local bind
        local lastThrowTime = 0
        local equipCooldown = false

        local crosshairPart, trackConn, bestTargetForAimlock
        local crosshairPos

        ----------------------------------------------------
        -- ANIMATION SETUP
        ----------------------------------------------------
        local Animation = Instance.new("Animation")
        Animation.AnimationId = "rbxassetid://944050359"
        local Track, Track2, Track3, Animator

        StarterGui:SetCore("SendNotification", {
            Title = "Legit Auto Throw",
            Text = state and "Legit throw enabled!" or "Legit throw disabled",
            Duration = 3
        })

        local function resetThrowSystem()
            if Track and Track.IsPlaying then Track:Stop() end
            if Track2 and Track2.IsPlaying then Track2:Stop() end
            if Track3 and Track3.IsPlaying then Track3:Stop() end
            Track, Track2, Track3, Animator = nil, nil, nil
            lastThrowTime = 0
        end

        local function hasToolEquipped()
            if not lp.Character then return false end
            for _, item in ipairs(lp.Character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "blade" then
                    return true
                end
            end
            return false
        end

        local function setupAnimator(character)
            local hum = character:WaitForChild("Humanoid")
            Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            character.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    resetThrowSystem()
                end
            end)
        end

        local function onToolEquipped(tool)
            if tool.Name:lower() == "blade" then
                resetThrowSystem()
                equipCooldown = true
                task.delay(0.25, function() equipCooldown = false end)

                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if hum then
                    Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                    Track = Animator:LoadAnimation(Animation)
                    Track2 = Animator:LoadAnimation(Animation)
                    Track3 = Animator:LoadAnimation(Animation)
                end
            end
        end

        local function ensureTrack()
            if not Animator then
                local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
                if not hum then return end
                Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
            end
            if not Track then Track = Animator:LoadAnimation(Animation) end
            if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
            if not Track3 then Track3 = Animator:LoadAnimation(Animation) end
        end

        local function playThrowAnimation()
            ensureTrack()
            if Track then Track:Play(5,10,3) end
            if Track2 then Track2:Play(5,10,3) end
            if Track3 then Track3:Play(5,10,3) end
        end

        local function hookCharacter(char)
            setupAnimator(char)
            char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name:lower() == "blade" then
                    onToolEquipped(child)
                end
            end)
        end

        if state then
            if lp.Character then hookCharacter(lp.Character) end
            lp.CharacterAdded:Connect(hookCharacter)
            lp.CharacterRemoving:Connect(resetThrowSystem)
            lp.Character.ChildAdded:Connect(onToolEquipped)
        end

        ----------------------------------------------------
        -- CROSSHAIR AND AIMLOCK LOGIC
        ----------------------------------------------------
        local function ensureCrosshairVisual()
            if crosshairPart and crosshairPart.Parent then return end
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.Shape = Enum.PartType.Ball
            p.Material = Enum.Material.Neon
            p.Color = Color3.new(1,0,0)
            p.Size = Vector3.new(0.35,0.35,0.35)
            p.Parent = workspace
            crosshairPart = p

            if bestTargetForAimlock then
                local raw = bestTargetForAimlock.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    crosshairPos = crosshairPos:Lerp(raw, 0.35)
                end
                crosshairPart.Position = crosshairPos
            end
        end

        local function stopCrosshairTracking()
            if trackConn then
                trackConn:Disconnect()
                trackConn = nil
            end
            if crosshairPart then
                crosshairPart:Destroy()
                crosshairPart = nil
            end
            crosshairPos = nil
            bestTargetForAimlock = nil
        end

        local function startLock()
            ensureCrosshairVisual()
            if trackConn then trackConn:Disconnect() end

            trackConn = RunService.RenderStepped:Connect(function()
                local t = bestTargetForAimlock
                if not t or not t.Parent then
                    stopCrosshairTracking()
                    return
                end

                local targetHum = t.Parent:FindFirstChild("Humanoid")
                if targetHum and targetHum.Health <= 0 then
                    stopCrosshairTracking()
                    ensureCrosshairVisual()
                    return
                end

                local raw = t.Position
                if not crosshairPos then
                    crosshairPos = raw
                else
                    local delta = (raw - crosshairPos).Magnitude
                    if delta > 1 then
                        crosshairPos = raw
                    else
                        crosshairPos = crosshairPos:Lerp(raw, 0.35)
                    end
                end

                if crosshairPart then
                    crosshairPart.Transparency = 0
                    crosshairPart.Position = crosshairPos
                end
            end)
        end

        local function fireKnife(bind)
            if not bind or not crosshairPart then return end
            local aimPos = crosshairPos
            if aimPos then
                pcall(function()
                    bind:Fire("t", CFrame.new(aimPos)) -- ORIGINAL THROW
                end)
            end
        end

        ----------------------------------------------------
        -- ULTRA-STABLE KILLFUNC SYSTEM
        ----------------------------------------------------
        local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer

        local function Notify(t)
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = t.Title or "Status",
                    Text = t.Text or "",
                    Duration = t.Duration or 5
                })
            end)
        end

        local function HardRescan()
            KillFunc = nil
            killSignatureFound = nil
            lastKillFuncPointer = nil
        end

        local function FindKillFunc()
            for _, v in pairs(getgc(false)) do
                if type(v) == "function" then
                    local ok, env = pcall(getfenv, v)
                    if ok and env then
                        local scr = env.script
                        local firstScript = lp.PlayerScripts:GetChildren()[1]
                        local firstScriptName = firstScript and firstScript.Name or ""

                        if scr and tostring(scr) == firstScriptName then
                            local constants = debug.getconstants(v)
                            for _, c in pairs(constants) do
                                if tostring(c) == "IIlIla" then
                                    if v ~= lastKillFuncPointer then
                                        killSignatureFound = nil
                                        lastKillFuncPointer = v
                                    end

                                    KillFunc = v

                                    if lastStatus ~= "found" then
                                        lastStatus = "found"
                                        Notify({
                                            Title = "KillFunc Status",
                                            Text = "KillFunc FOUND ✔",
                                            Duration = 6
                                        })
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
            end

            if lastStatus ~= "notfound" then
                lastStatus = "notfound"
                Notify({
                    Title = "KillFunc Status",
                    Text = "KillFunc NOT FOUND ❌ — rescanning...",
                    Duration = 6
                })
            end
            return false
        end

        local function safe(fn, ...)
            return pcall(fn, ...)
        end

        local function GetSkid()
            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= lp and plr.Character then
                    local backpack = plr:FindFirstChildOfClass("Backpack")
                    local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                    if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                        return plr
                    end
                end
            end
            return nil
        end

        local function TryKillWithoutDestroy(part)
            if not KillFunc then return false end
            local success = false

            if killSignatureFound == 1 then
                success = safe(KillFunc, part, true, part.Position)
            elseif killSignatureFound == 2 then
                success = safe(KillFunc, part, part.Position, true)
            elseif killSignatureFound == 3 then
                success = safe(KillFunc, part, true)
            else
                if safe(KillFunc, part, true, part.Position) then
                    killSignatureFound = 1
                    success = true
                elseif safe(KillFunc, part, part.Position, true) then
                    killSignatureFound = 2
                    success = true
                elseif safe(KillFunc, part, true) then
                    killSignatureFound = 3
                    success = true
                end
            end
            return success
        end

        ------------------------------------------------------------------
        -- WATCHDOG
        ------------------------------------------------------------------
        task.spawn(function()
            while alwaysHit2Active do
                if not KillFunc then
                    FindKillFunc()
                end
                RunService.Heartbeat:Wait()
            end
        end)

        ------------------------------------------------------------------
        -- MAIN LOOP (HIT REGISTER)
        ------------------------------------------------------------------
        task.spawn(function()
            local attemptAccumulator = 0
            local BASE_INTERVAL = 0.05

            RunService.Heartbeat:Connect(function(deltaTime)
                if not alwaysHit2Active then return end
                local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                attemptAccumulator = attemptAccumulator + deltaTime
                if attemptAccumulator < interval then return end
                attemptAccumulator = 0

                if box2Active then
                    local target = GetSkid()
                    if target and target.Character then
                        local part = target.Character:FindFirstChild("HumanoidRootPart")
                        if part then
                            TryKillWithoutDestroy(part)
                        end
                    end
                end
            end)
        end)

        ------------------------------------------------------------------
        -- AUTO-THROW LOOP
        ------------------------------------------------------------------
        task.spawn(function()
            while box2Active do
                task.wait()
                if not lp.Character or not lp.Character:FindFirstChild("Humanoid") then continue end
                if lp.Character.Humanoid.Health <= 0 then continue end
                if not hasToolEquipped() then continue end

                bind = lp.PlayerScripts:FindFirstChild("Event") or bind
                if not bind then continue end

                local camera = Workspace.CurrentCamera
                local bestTarget, bestDist = nil, math.huge

                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local hum = plr.Character:FindFirstChild("Humanoid")
                        local head = plr.Character:FindFirstChild("Head")
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

                        if hum and hum.Health > 0 and head and hasBlade then
                            local dist = (head.Position - camera.CFrame.Position).Magnitude
                            if dist < bestDist then
                                bestTarget, bestDist = head, dist
                            end
                        end
                    end
                end

                if bestTarget and tick() - lastThrowTime >= 1 and not equipCooldown then
                    lastThrowTime = tick()
                    bestTargetForAimlock = bestTarget

                    startLock()
                    pcall(FindKillFunc)

                    task.delay(0, function()
                        if not box2Active then return end
                        playThrowAnimation()
                        playThrowAnimation()
                        RunService.RenderStepped:Wait()
                        task.wait(0.25)
                        startLock()
                        fireKnife(bind)

                        -- detached kill check
                        local target = GetSkid()
                        if target and target.Character then
                            local part = target.Character:FindFirstChild("HumanoidRootPart")
                            if part then
                                TryKillWithoutDestroy(part)
                            end
                        end
                    end)
                end
            end
        end)
    end
},

["Force Players to Kill (Secret)"] = {
button = forceButton,
state = false,
toggleFunction = function(state)
forceActive = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Secrecy 😈",
Text = "Force rape enabled! rape them lol.",
Duration = 3;
})

spawn(function()
while forceActive do
game:GetService("ReplicatedStorage").RemoteEvent:FireServer(16, "secret")
wait()
end
end)
end
end
},

["Force Players to Kill (Public)"] = {
button = force2Button,
state = false,
toggleFunction = function(state)
force2Active = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Publicity ??",
Text = "Force rape enabled! rape  them lol.",
Duration = 3;
})

spawn(function()
while force2Active do
game:GetService("ReplicatedStorage").RemoteEvent:FireServer(16, "public")
wait()
end
end)
end
end
},

["Auto Throw Bulb V2"] = {
button = bulb3Button,
state = false,
toggleFunction = function(state)
bulb3Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb3Active do
task.wait(0)

if not boxActive then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb V2 Head"] = {
button = bulb4Button,
state = false,
toggleFunction = function(state)
bulb4Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb4Active do
task.wait(0)

if not box2Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos V2"] = {
button = bulbDuo1Button,
state = false,
toggleFunction = function(state)
bulbDuo1Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbDuo1Active do
task.wait(0)

-- Only run if duo throw is active
if not duoHit1Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos V2 Head"] = {
button = bulbDuo2Button,
state = false,
toggleFunction = function(state)
bulbDuo2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbDuo2Active do
task.wait(0)

-- Only run if duo throw is active
if not duoHit2Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb"] = {
button = bulb2Button,
state = false,
toggleFunction = function(state)
bulb2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb2Active do
task.wait(0)

if not hitbox2Active and not (boxActive and box2Active) then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
task.wait(0.01)
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
task.wait(0.01)
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Track3
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
Track3 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 3) end
if Track2 then Track2:Play(5, 10, 3) end
if Track3 then Track3:Play(5, 10, 3) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.25)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos"] = {
button = bulbButton,
state = false,
toggleFunction = function(state)
bulbActive = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbActive do
task.wait(0)

-- Only run if duo throw is active
if not duoHitbox2Active and not (duoHit1Active and duoHit2Active) then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
task.wait(0.01)
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
task.wait(0.01)
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Track3
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
Track3 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 3) end
if Track2 then Track2:Play(5, 10, 3) end
if Track3 then Track3:Play(5, 10, 3) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.25)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Head/Body Semi"] = {
button = bodyButton,
state = false,
toggleFunction = function(state)
bodyActive = state

if state then
_G.HeadSize = 5
_G.HumanoidRootPartSize = 5
_G.HitboxExpandEnabled = true

-- Head loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
if head then
head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
head.Transparency = 1
head.BrickColor = BrickColor.new("Really blue")
head.Material = "Neon"
head.CanCollide = true
end
end)
end
end
end
end)
end)

-- HRP loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if hrp then
hrp.Size = Vector3.new(_G.HumanoidRootPartSize, _G.HumanoidRootPartSize, _G.HumanoidRootPartSize)
hrp.Transparency = 1
hrp.BrickColor = BrickColor.new("Really blue")
hrp.Material = "Neon"
hrp.CanCollide = false
end
end)
end
end
end
end)
end)

else
_G.HitboxExpandEnabled = false

-- Reset sizes
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if head then
head.Size = Vector3.new(2, 1, 1)
head.Transparency = 0
head.BrickColor = BrickColor.new("Medium stone grey")
head.Material = Enum.Material.Plastic
head.CanCollide = true
end
if hrp then
hrp.Size = Vector3.new(2, 2, 1)
hrp.Transparency = 0
hrp.BrickColor = BrickColor.new("Medium stone grey")
hrp.Material = Enum.Material.Plastic
hrp.CanCollide = true
end
end)
end
end
end
end
},

["Hitbox Expander"] = {
button = expanderButton,
state = false,
toggleFunction = function(state)
expanderActive = state

if state then
_G.HeadSize = 5
_G.HumanoidRootPartSize = 5
_G.HitboxExpandEnabled = true

-- Head loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
if head then
head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
head.Transparency = 1
head.BrickColor = BrickColor.new("Really blue")
head.Material = "Neon"
head.CanCollide = false
end
end)
end
end
end
end)
end)

-- HRP loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if hrp then
hrp.Size = Vector3.new(_G.HumanoidRootPartSize, _G.HumanoidRootPartSize, _G.HumanoidRootPartSize)
hrp.Transparency = 1
hrp.BrickColor = BrickColor.new("Really blue")
hrp.Material = "Neon"
hrp.CanCollide = false
end
end)
end
end
end
end)
end)

else
_G.HitboxExpandEnabled = false

-- Reset sizes
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if head then
head.Size = Vector3.new(2, 1, 1)
head.Transparency = 0
head.BrickColor = BrickColor.new("Medium stone grey")
head.Material = Enum.Material.Plastic
head.CanCollide = true
end
if hrp then
hrp.Size = Vector3.new(2, 2, 1)
hrp.Transparency = 0
hrp.BrickColor = BrickColor.new("Medium stone grey")
hrp.Material = Enum.Material.Plastic
hrp.CanCollide = true
end
end)
end
end
end
end
},

["Kill Aura"] = {
    button = killAuraButton,
    state = false,
    toggleFunction = function(state)
        killAuraActive = state

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local lp = Players.LocalPlayer

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Kill Aura",
                Text = "Ultra Kill Aura enabled",
                Duration = 3
            })

            -- Cleanup old connections
            if getgenv().configs and getgenv().configs.Disable then
                getgenv().configs.Disable:Fire()
            end

            local Disable = Instance.new("BindableEvent")
            getgenv().configs = {
                Disable = Disable,
                Size = Vector3.new(25, 25, 25),   -- BIGGER HITBOX
                DeathCheck = true,
                connections = {}
            }

            local function getchar(plr)
                return plr.Character
            end

            local function gethum(plr)
                local c = getchar(plr)
                return c and c:FindFirstChildWhichIsA("Humanoid")
            end

            local function alive(h)
                return h and h.Health > 0
            end

            -- super-optimized attack
            local function Attack(tool, touchPart, targetPart)
                tool:Activate()

                -- triple touch for guaranteed hit
                for i = 1, 3 do
                    firetouchinterest(touchPart, targetPart, 1)
                    firetouchinterest(touchPart, targetPart, 0)
                end
            end

            local connection
            connection = RunService.RenderStepped:Connect(function()
                if not killAuraActive then
                    connection:Disconnect()
                    return
                end

                local char = getchar(lp)
                local hum = gethum(lp)
                if not alive(hum) then return end

                local tool = char and char:FindFirstChildWhichIsA("Tool")
                if not tool then return end

                local touch = tool:FindFirstChildWhichIsA("TouchTransmitter", true)
                if not touch then return end
                local touchPart = touch.Parent

                -- FAST hitbox scanning
                local box = workspace:GetPartBoundsInBox(
                    touchPart.CFrame,
                    touchPart.Size + getgenv().configs.Size,
                    OverlapParams.new()
                )

                for _, part in ipairs(box) do
                    local model = part:FindFirstAncestorWhichIsA("Model")
                    if model and model ~= char then
                        local plr = Players:GetPlayerFromCharacter(model)

                        -- only requirement: MUST BE a player & not you
                        if plr and plr ~= lp then
                            local hum2 = gethum(plr)
                            if alive(hum2) then
                                Attack(tool, touchPart, part)
                            end
                        end
                    end
                end
            end)

            table.insert(getgenv().configs.connections, connection)

            Disable.Event:Connect(function()
                if connection then connection:Disconnect() end
            end)

        else
            if getgenv().configs and getgenv().configs.Disable then
                getgenv().configs.Disable:Fire()
            end
        end
    end
},

["Kill Aura Duos"] = {
    button = killAura2Button,
    state = false,
    toggleFunction = function(state)
        killAura2Active = state

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local lp = Players.LocalPlayer

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Kill Aura",
                Text = "Ultra Kill Aura enabled",
                Duration = 3
            })

            -- Cleanup old connections
            if getgenv().configs and getgenv().configs.Disable then
                getgenv().configs.Disable:Fire()
            end

            local Disable = Instance.new("BindableEvent")
            getgenv().configs = {
                Disable = Disable,
                Size = Vector3.new(25, 25, 25),   -- MUCH BIGGER HITBOX
                DeathCheck = true,
                connections = {}
            }

            local function getchar(plr)
                return plr.Character
            end

            local function gethum(plr)
                local c = getchar(plr)
                return c and c:FindFirstChildWhichIsA("Humanoid")
            end

            local function alive(h)
                return h and h.Health > 0
            end

            -- cache team color checker for speed
            local function isEnemy(plr)
                return plr.TeamColor ~= lp.TeamColor
            end

            -- super-optimized attack
            local function Attack(tool, touchPart, targetPart)
                tool:Activate()

                -- multiple attempts = instant registration
                for i = 1, 3 do
                    firetouchinterest(touchPart, targetPart, 1)
                    firetouchinterest(touchPart, targetPart, 0)
                end
            end

            local connection
            connection = RunService.RenderStepped:Connect(function()
                if not killAura2Active then
                    connection:Disconnect()
                    return
                end

                local char = getchar(lp)
                local hum = gethum(lp)
                if not alive(hum) then return end

                local tool = char and char:FindFirstChildWhichIsA("Tool")
                if not tool then return end

                local touch = tool:FindFirstChildWhichIsA("TouchTransmitter", true)
                if not touch then return end
                local touchPart = touch.Parent

                -- FASTEST detection method
                local box = workspace:GetPartBoundsInBox(
                    touchPart.CFrame,
                    touchPart.Size + getgenv().configs.Size,
                    OverlapParams.new()
                )

                for _, part in ipairs(box) do
                    local model = part:FindFirstAncestorWhichIsA("Model")
                    if model and model ~= char then
                        local plr = Players:GetPlayerFromCharacter(model)

                        -- must be a player & enemy
                        if plr and isEnemy(plr) then
                            local hum2 = gethum(plr)
                            if alive(hum2) then
                                Attack(tool, touchPart, part)
                            end
                        end
                    end
                end
            end)

            table.insert(getgenv().configs.connections, connection)

            Disable.Event:Connect(function()
                if connection then connection:Disconnect() end
            end)

        else
            if getgenv().configs and getgenv().configs.Disable then
                getgenv().configs.Disable:Fire()
            end
        end
    end
},

["Radius Auto Stab"] = {
    button = radiusStabButton,
    state = false,
    toggleFunction = function(state)
        radiusActive = state

        local Players = game:GetService("Players")
        local lp = Players.LocalPlayer
        local RunService = game:GetService("RunService")
        local VirtualInputManager = game:GetService("VirtualInputManager")

        local stabLoop = nil
        local radius = 7 -- set your radius here

        -- check if BLade in char or backpack
        local function HasBlade(plr)
            if not plr.Character then return false end
            local char = plr.Character
            local backpack = plr:FindFirstChildOfClass("Backpack")

            return char:FindFirstChild("Blade") 
                or (backpack and backpack:FindFirstChild("Blade"))
        end

        -- find closest blade user inside radius
        local function GetTarget()
            local best = nil
            local c = lp.Character
            if not c or not c:FindFirstChild("HumanoidRootPart") then return nil end
            local mypos = c.HumanoidRootPart.Position

            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= lp and plr.Character and HasBlade(plr) then
                    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local dist = (hrp.Position - mypos).Magnitude
                        if dist <= radius then
                            best = plr
                            break
                        end
                    end
                end
            end

            return best
        end

        -- stab loop function
        local function StartStabLoop()
            if stabLoop then return end -- already running

            stabLoop = task.spawn(function()
                while radiusActive and GetTarget() do
                    -- nonstop stabbing
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                    task.wait(0.05) -- fast spam speed, adjust if needed
                end

                -- no more targets → allow new loop later
                stabLoop = nil
            end)
        end

        if state then
            -- notify
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Radius Auto Stab",
                Text = "Enabled.",
                Duration = 3
            })

            -- detection loop
            RunService.Heartbeat:Connect(function()
                if not radiusActive then return end

                if GetTarget() then
                    StartStabLoop()
                else
                    -- no target; if loop exists kill it
                    if stabLoop then
                        task.cancel(stabLoop)
                        stabLoop = nil
                    end
                end
            end)

        else
            -- disable + kill stab loop
            radiusActive = false
            if stabLoop then
                task.cancel(stabLoop)
                stabLoop = nil
            end
        end
    end
},

["Radius Auto Stab (Duos)"] = {
    button = radiusStab2Button,
    state = false,
    toggleFunction = function(state)
        radius2Active = state

        local Players = game:GetService("Players")
        local lp = Players.LocalPlayer
        local RunService = game:GetService("RunService")
        local VirtualInputManager = game:GetService("VirtualInputManager")

        local stabLoop = nil
        local radius = 7 -- set your radius here

        -- check if BLade in char or backpack
        local function HasBlade(plr)
            if not plr.Character then return false end
            local char = plr.Character
            local backpack = plr:FindFirstChildOfClass("Backpack")

            return char:FindFirstChild("Blade") 
                or (backpack and backpack:FindFirstChild("Blade"))
        end

        -- find closest blade user inside radius
        local function GetTarget()
            local c = lp.Character
            if not c or not c:FindFirstChild("HumanoidRootPart") then return nil end

            local mypos = c.HumanoidRootPart.Position

            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= lp and p.Character then

                    -- 💠 TEAMCHECK (ignore teammate)
                    local targetTeamColor = p.TeamColor
                    if speakerTeamColor and targetTeamColor and speakerTeamColor == targetTeamColor then
                        continue
                    end

                    -- must have blade
                    if not HasBlade(p) then continue end

                    local hrp = p.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        if (hrp.Position - mypos).Magnitude <= radius then
                            return p
                        end
                    end
                end
            end

            return nil
        end

        -- stab loop function
        local function StartStabLoop()
            if stabLoop then return end -- already running

            stabLoop = task.spawn(function()
                while radius2Active and GetTarget() do
                    -- nonstop stabbing
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                    task.wait(0.05) -- fast spam speed, adjust if needed
                end

                -- no more targets → allow new loop later
                stabLoop = nil
            end)
        end

        if state then
            -- notify
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Radius Auto Stab",
                Text = "Enabled.",
                Duration = 3
            })

            -- detection loop
            RunService.Heartbeat:Connect(function()
                if not radius2Active then return end

                if GetTarget() then
                    StartStabLoop()
                else
                    -- no target; if loop exists kill it
                    if stabLoop then
                        task.cancel(stabLoop)
                        stabLoop = nil
                    end
                end
            end)

        else
            -- disable + kill stab loop
            radiusActive = false
            if stabLoop then
                task.cancel(stabLoop)
                stabLoop = nil
            end
        end
    end
},

["Auto Reach"] = {
button = reachButton,
state = false,
toggleFunction = function(state)
reachActive = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Auto Reach",
Text = "Auto reach enabled! Compatible with Headless now.",
Duration = 3;
})

stopFireTap()

local function runReach()
task.spawn(function()
local SCAN_RANGE  = 4
local BEHIND_DIST = 1
local SCAN_DELAY  = 0

local speaker = Players.LocalPlayer

while reachActive do
task.wait(SCAN_DELAY)

local character = speaker.Character
if not character then continue end

local tool = tools(speaker)
if not tool then continue end

local myRoot = character:FindFirstChild("HumanoidRootPart")
if not myRoot then continue end

local found = false

for _, p in ipairs(Players:GetPlayers()) do
if p ~= speaker and p.Character and playerHasBlade(p) then
local targetRoot = p.Character:FindFirstChild("HumanoidRootPart")
local hum = p.Character:FindFirstChildOfClass("Humanoid")
if targetRoot and hum and hum.Health > 0 then
local dist = (myRoot.Position - targetRoot.Position).Magnitude
if dist <= SCAN_RANGE then
attachBehind(speaker, p, BEHIND_DIST)
fireTap()
found = true
break
end
end
end
end

if not found then
fireTapRunning = false
end
end
end)
end

runReach()

Players.LocalPlayer.CharacterAdded:Connect(function()
if reachActive then
task.wait(1)
runReach()
stopFireTap()
end
end)
end
end
},

["Auto Reach Duos"] = {
button = reach2Button,
state = false,
toggleFunction = function(state)
reach2Active = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Auto Reach Duos",
Text = "Auto reach for duos enabled! Compatible with Headless now.",
Duration = 3;
})

stopFireTap()

local function runReachDuos()
task.spawn(function()
local SCAN_RANGE  = 4
local BEHIND_DIST = 1
local SCAN_DELAY  = 0

local speaker = Players.LocalPlayer

while reach2Active do
task.wait(SCAN_DELAY)

local character = speaker.Character
if not character then continue end

local tool = tools(speaker)
if not tool then continue end

local myRoot = character:FindFirstChild("HumanoidRootPart")
if not myRoot then continue end

local found = false

for _, p in ipairs(Players:GetPlayers()) do
if p ~= speaker and p.Character and playerHasBlade(p) then
local speakerTeamColor = speaker.TeamColor
local targetTeamColor = p.TeamColor

if speakerTeamColor and targetTeamColor and speakerTeamColor == targetTeamColor then
continue
end

local targetRoot = p.Character:FindFirstChild("HumanoidRootPart")
local hum = p.Character:FindFirstChildOfClass("Humanoid")
if targetRoot and hum and hum.Health > 0 then
local dist = (myRoot.Position - targetRoot.Position).Magnitude
if dist <= SCAN_RANGE then
attachBehind(speaker, p, BEHIND_DIST)
fireTap()
found = true
break
end
end
end
end

if not found then
fireTapRunning = false
end
end
end)
end

runReachDuos()

Players.LocalPlayer.CharacterAdded:Connect(function()
if reach2Active then
task.wait(1)
runReachDuos()
stopFireTap()
end
end)
end
end
},

["Full Bright"] = {
button = fullBrightButton,
state = false,
toggleFunction = function(state)
fullBrightActive = state
local Lighting = game:GetService("Lighting")

if state then
Lighting.Brightness = 2
Lighting.ClockTime = 14
Lighting.FogEnd = 100000
Lighting.GlobalShadows = false
Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
else
-- Restore default Lighting settings when toggled OFF
Lighting.Brightness = 1
Lighting.ClockTime = 12
Lighting.FogEnd = 1000
Lighting.GlobalShadows = true
Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
end
end
}
}

-- Button Toggle Function
local function toggleButtonState(featureName)
local feature = features[featureName]
if feature then
feature.state = not feature.state  -- Toggle the state
feature.button.Text = featureName .. (feature.state and ": ON" or ": OFF")
feature.button.BackgroundColor3 = feature.state and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(40, 40, 40)

-- Call the specific toggle function for the feature
feature.toggleFunction(feature.state)
end
end

-- Connect buttons to toggle function
for featureName, data in pairs(features) do
data.button.MouseButton1Click:Connect(function()
toggleButtonState(featureName)
end)
end

-- Tab Switching
mainTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = true
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = false
end)

settingsTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = true
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = false
end)

featuresTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = true
aboutTab.Visible = false
detailsTab.Visible = false
end)

aboutTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = true
detailsTab.Visible = false
end)

detailsTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = true
end)

-- Notification Pop-up (Smooth & Aesthetic)
local popupFrame = Instance.new("Frame")
popupFrame.Size = UDim2.new(0, 250, 0, 100)
popupFrame.Position = UDim2.new(0.5, -125, 0.5, -50) -- Centered
popupFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
popupFrame.BackgroundTransparency = 1 -- Start hidden
popupFrame.Parent = screenGui

local popupStroke = Instance.new("UIStroke")
popupStroke.Thickness = 2
popupStroke.Color = Color3.fromRGB(220, 20, 60) -- Crimson stroke
popupStroke.Parent = popupFrame

local popupCorner = Instance.new("UICorner")
popupCorner.CornerRadius = UDim.new(0, 10)
popupCorner.Parent = popupFrame

local popupText = Instance.new("TextLabel")
popupText.Size = UDim2.new(1, -20, 1, -20)
popupText.Position = UDim2.new(0, 10, 0, 10)
popupText.BackgroundTransparency = 1
popupText.Text = "Made by Day. ENJOY! Day's BP Shitter XD 1.0"
popupText.TextColor3 = Color3.fromRGB(255, 255, 255)
popupText.Font = Enum.Font.GothamBold
popupText.TextSize = 16 -- Slightly smaller for clean look
popupText.TextWrapped = true
popupText.TextScaled = true
popupText.TextTransparency = 1 -- Start hidden
popupText.Parent = popupFrame

-- Smooth Pop-up Animation
task.spawn(function()
for i = 1, 0, -0.1 do
popupFrame.BackgroundTransparency = i
popupText.TextTransparency = i
task.wait(0.02) -- Fast yet smooth
end

task.wait(2) -- Keep for 2 seconds

for i = 0, 1, 0.1 do
popupFrame.BackgroundTransparency = i
popupText.TextTransparency = i
task.wait(0.02) -- Smooth fade-out
end
popupFrame:Destroy()
end)

-- GUI Open/Close Animation
local isUIVisible = false
toggleButton.MouseButton1Click:Connect(function()
isUIVisible = not isUIVisible

if isUIVisible then
frame.Size = UDim2.new(0, 0, 0, 0)
frame.Position = UDim2.new(0.5, 0, 0.5, 0)
frame.BackgroundTransparency = 1
frame.Visible = true

-- Smooth Expand
for i = 0, 1, 0.05 do
local t = math.sin(i * (math.pi / 2))
frame.Size = UDim2.new(0, 300 * t, 0, 250 * t)
frame.Position = UDim2.new(0.5, -150 * t, 0.5, -125 * t)
frame.BackgroundTransparency = 1 - t
task.wait(0.015)
end
else
-- Smooth Shrink
for i = 1, 0, -0.05 do
local t = math.sin(i * (math.pi / 2))
frame.Size = UDim2.new(0, 300 * t, 0, 250 * t)
frame.Position = UDim2.new(0.5, -150 * t, 0.5, -125 * t)
frame.BackgroundTransparency = 1 - t
task.wait(0.015)
end
frame.Visible = false
end
end)
end)

task.spawn(function()
local player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local plrs = game:GetService("Players")
local lp = plrs.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer

-- Screen GUI
local screenGui = Instance.new("ScreenGui")
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- UI Frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 300, 0, 250)
frame.Position = UDim2.new(0.5, -150, 0.5, -125)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BackgroundTransparency = 0.1
frame.Visible = false
frame.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 3)
uiCorner.Parent = frame

local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(220, 20, 60)
stroke.Parent = frame

-- Floating Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 35, 0, 35)
toggleButton.Position = UDim2.new(1, -45, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.Text = "DAY"
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 14
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Visible = true
toggleButton.Parent = screenGui

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleButton

-- Tabs Section
local tabFrame = Instance.new("Frame")
tabFrame.Size = UDim2.new(1, 0, 0, 30)
tabFrame.Position = UDim2.new(0, 0, 0, 0)
tabFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
tabFrame.Parent = frame

-- Function to create tab buttons
local function createTabButton(name, position)
  local button = Instance.new("TextButton")
  button.Text = name
  button.Size = UDim2.new(0.25, -5, 0, 25)
  button.Position = UDim2.new(position, 5, 0, 2)
  button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
  button.Font = Enum.Font.GothamBold
  button.TextColor3 = Color3.fromRGB(200, 200, 200)
  button.TextSize = 12
  button.Parent = tabFrame

  local corner = Instance.new("UICorner")
  corner.CornerRadius = UDim.new(0, 6)
  corner.Parent = button

  return button
end

-- Create 4 tab buttons
local mainTabButton = createTabButton("Solo", 0)
local settingsTabButton = createTabButton("Duos", 0.18)
local featuresTabButton = createTabButton("Etc", 0.36)
local aboutTabButton = createTabButton("More", 0.54)
local detailsTabButton = createTabButton("Extra", 0.72)

-- Create the actual tab contents
local function createTab(parent)
  local tab = Instance.new("Frame")
  tab.Size = UDim2.new(1, 0, 1, -30)
  tab.Position = UDim2.new(0, 0, 0, 30)
  tab.BackgroundTransparency = 1
  tab.Parent = parent
  tab.Visible = false
  return tab
end

local mainTab = createTab(frame)
local settingsTab = createTab(frame)
local featuresTab = createTab(frame)
local aboutTab = createTab(frame)
local detailsTab = createTab(frame)

mainTab.Visible = true -- Default tab

-- Function to create toggle buttons
local function createToggleButton(text, parent, position)
  local button = Instance.new("TextButton")
  button.Size = UDim2.new(1, -10, 0, 25)
  button.Position = UDim2.new(0, 5, 0, position)
  button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
  button.Font = Enum.Font.GothamBold
  button.TextColor3 = Color3.fromRGB(200, 200, 200)
  button.TextSize = 12
  button.Text = text .. ": OFF"
  button.Parent = parent

  local corner = Instance.new("UICorner")
  corner.CornerRadius = UDim.new(0, 6)
  corner.Parent = button

  return button
end

-- Main Tab Section
-- Add Toggle Buttons for Each Tab
local aimbotButton = createToggleButton("Kill Aura & Always Hit", mainTab, 5)
local killAuraButton = createToggleButton("Kill Aura", mainTab, 35)
local extraButton = createToggleButton("Legit Auto Throw", mainTab, 65)
local alwaysHitButton = createToggleButton("Register Hit (Body)", mainTab, 95)
local alwaysHit2Button = createToggleButton("Register Hit (Head)", mainTab, 125)
local reachButton = createToggleButton("Auto Reach", mainTab, 155)
local alwaysHit3Button = createToggleButton("Register Hit (All Body Parts)", mainTab, 185)

-- Settings Tab Section
local extra2Button = createToggleButton("Legit Auto Throw (Duos)", settingsTab, 5)
local duoAlwaysHitButton = createToggleButton("Register Hit Duos (Body)", settingsTab, 35)
local duoAlwaysHit2Button = createToggleButton("Register Hit Duos (Head)", settingsTab, 65)
local reach2Button = createToggleButton("Auto Reach Duos", settingsTab, 95)
local duoAlwaysHit3Button = createToggleButton("Register Hit Duos (All Body Parts)", settingsTab, 125)
local bulbButton = createToggleButton("Auto Throw Bulb Duos", settingsTab, 155)
local bulb2Button = createToggleButton("Auto Throw Bulb", settingsTab, 185)

-- About Tab Section
local bulb3Button = createToggleButton("Auto Throw Bulb V2", aboutTab, 5)
local bulb4Button = createToggleButton("Auto Throw Bulb V2 Head", aboutTab, 35)
local bulbDuo1Button = createToggleButton("Auto Throw Bulb Duos V2", aboutTab, 65)
local bulbDuo2Button = createToggleButton("Auto Throw Bulb Duos V2 Head", aboutTab, 95)
local bodyButton = createToggleButton("Head/Body Semi", aboutTab, 125)
local expanderButton = createToggleButton("Hitbox Expander", aboutTab, 155)

-- Details Tab Section
local anotherButton = createToggleButton("Legit Auto Throw V2", detailsTab, 5)
local headHitButton = createToggleButton("Legit Auto Throw V2 (Head)", detailsTab, 35)
local forceButton = createToggleButton("Force Players to Kill (Secret)", detailsTab, 65)
local force2Button = createToggleButton("Force Players to Kill (Public)", detailsTab, 95)
local duoHit1Button = createToggleButton("Legit Auto Throw Duos V2", detailsTab, 125)
local duoHit2Button = createToggleButton("Legit Auto Throw Duos V2 (Head)", detailsTab, 155)
local fullBrightButton = createToggleButton("Full Bright", detailsTab, 185)

-- helpers
function tools(plr)
  local bp = plr:FindFirstChildOfClass("Backpack")
  local inBP = bp and bp:FindFirstChild("blade") or bp and bp:FindFirstChild("Blade")
  local inHand = plr.Character and (plr.Character:FindFirstChild("blade") or plr.Character:FindFirstChild("Blade"))
  return inHand or inBP
end

function getRoot(char)
  return char:FindFirstChild("HumanoidRootPart")
  or char:FindFirstChild("Torso")
  or char:FindFirstChild("UpperTorso")
end

function playerHasBlade(p)
  local tool = p.Character and p.Character:FindFirstChildOfClass("Tool")
  if tool and tool.Name:lower():find("blade") then return true end

  local bp = p:FindFirstChildOfClass("Backpack")
  if bp then
    for _, t in ipairs(bp:GetChildren()) do
      if t:IsA("Tool") and t.Name:lower():find("blade") then
        return true
      end
    end
  end
  return false
end

local TweenService = game:GetService("TweenService")

function attachBehind(speaker, target, dist)
  local char = speaker.Character
  local hrp = getRoot(char)
  local thrp = getRoot(target.Character)
  if not (hrp and thrp) then return end

  local backPos = thrp.Position - thrp.CFrame.LookVector * dist
  local newCFrame = CFrame.new(backPos, thrp.Position)

  local tween = TweenService:Create(hrp, TweenInfo.new(0.05, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {CFrame = newCFrame})
  tween:Play()
  tween.Completed:Connect(function()
  local tool = tools(speaker)
  if tool then
    tool.Parent = char
    fireTap() -- Tap right after tween finishes
  else
    notify("Tool Required", "You need to hold a tool to stab.")
  end
  end)
end

local fireTapRunning = false

function fireTap()
  if fireTapRunning then return end
  fireTapRunning = true

  task.spawn(function()
  local VIM = game:GetService("VirtualInputManager")

  while fireTapRunning do
    VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
    task.wait(0.1)
  end
  end)
end

function stopFireTap()
  fireTapRunning = false
end

local function stopFireTapOnDeath(character)
  local humanoid = character:FindFirstChildOfClass("Humanoid")
  if humanoid then
    humanoid.Died:Connect(function()
    stopFireTap()  -- Stop fireTap when the character dies
    end)
  end
end

-- Setup on current character if exists
if Players.LocalPlayer.Character then
  stopFireTapOnDeath(Players.LocalPlayer.Character)
end

-- Setup on respawn
Players.LocalPlayer.CharacterAdded:Connect(function(char)
stopFireTapOnDeath(char)  -- Ensure fireTap stops when the player respawns
fireTapRunning = false  -- Reset the fireTapRunning flag when respawning
end)

-- Feature states
local features = {
  ["Kill Aura & Always Hit"] = { button = aimbotButton, state = false, toggleFunction = function(state)
  aimbotActive = state

  if state then
    game:GetService("StarterGui"):SetCore("SendNotification", {
      Title = "Kill Aura // Always Hit",
      Text = "Loaded! Always hit will trade ban you.",
      Duration = 3;
    })

    loadstring(game:HttpGet(("https://pastebin.com/raw/7c8Bw0ve"), true))()
  end
end
},

["Register Hit Duos (Body)"] = {
    button = duoAlwaysHitButton,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHitActive = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Body hits enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            local function GetSkid()
                local myTeamColor = lp.TeamColor
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        if not (myTeamColor and plr.TeamColor and plr.TeamColor == myTeamColor) then
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                            if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                                return plr
                            end
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- KILLFUNC SYSTEM
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refreshes loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect existing connections
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- Restart watchdog & main loop
                task.spawn(function()
                    -- WATCHDOG
                    table.insert(_connections, task.spawn(function()
                        while duoAlwaysHitActive do
                            if not KillFunc then FindKillFunc() end
                            RunService.Heartbeat:Wait()
                        end
                    end))

                    -- MAIN LOOP
                    table.insert(_connections, task.spawn(function()
                        local attemptAccumulator = 0
                        local BASE_INTERVAL = 0.05
                        RunService.Heartbeat:Connect(function(deltaTime)
                            if not duoAlwaysHitActive then return end
                            local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                            attemptAccumulator = attemptAccumulator + deltaTime
                            if attemptAccumulator < interval then return end
                            attemptAccumulator = 0

                            if duoHitbox2Active then
                                local target = GetSkid()
                                if target and target.Character then
                                    local part = target.Character:FindFirstChild("HumanoidRootPart")
                                    if part then
                                        safe(function()
                                            local ok = TryKill(part)
                                            if not ok then
                                                safe(KillFunc, part, true, part.Position)
                                            end
                                        end)
                                    end
                                end
                            end
                        end)
                    end))
                end)
            end

            -- initial loop start
            SoftResetLoops()

            -- connect respawn
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops) -- only refresh loops on respawn
                end)
            end
        end
    end
},

["Register Hit Duos (Head)"] = {
    button = duoAlwaysHit2Button,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHit2Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Headshots enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            local function GetSkid()
                local myTeamColor = lp.TeamColor
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        if not (myTeamColor and plr.TeamColor and plr.TeamColor == myTeamColor) then
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                            if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                                return plr
                            end
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- KILLFUNC SYSTEM
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refreshes loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect existing connections
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- Restart watchdog & main loop
                task.spawn(function()
                    -- WATCHDOG
                    table.insert(_connections, task.spawn(function()
                        while duoAlwaysHit2Active do
                            if not KillFunc then FindKillFunc() end
                            RunService.Heartbeat:Wait()
                        end
                    end))

                    -- MAIN LOOP
                    table.insert(_connections, task.spawn(function()
                        local attemptAccumulator = 0
                        local BASE_INTERVAL = 0.05
                        RunService.Heartbeat:Connect(function(deltaTime)
                            if not duoAlwaysHit2Active then return end
                            local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                            attemptAccumulator = attemptAccumulator + deltaTime
                            if attemptAccumulator < interval then return end
                            attemptAccumulator = 0

                            if duoHitbox2Active then
                                local target = GetSkid()
                                if target and target.Character then
                                    local part = target.Character:FindFirstChild("Head")
                                    if part then
                                        safe(function()
                                            local ok = TryKill(part)
                                            if not ok then
                                                safe(KillFunc, part, true, part.Position)
                                            end
                                        end)
                                    end
                                end
                            end
                        end)
                    end))
                end)
            end

            -- initial loop start
            SoftResetLoops()

            -- connect respawn
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops) -- only refresh loops on respawn
                end)
            end
        end
    end
},

["Register Hit (Body)"] = {
    button = alwaysHitButton,
    state = false,
    toggleFunction = function(state)
        alwaysHitActive = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Body hits enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            local function GetSkid()
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                        if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                            return plr
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- KILLFUNC SYSTEM
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refreshes loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect existing connections
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- Restart watchdog & main loop
                task.spawn(function()
                    -- WATCHDOG
                    table.insert(_connections, task.spawn(function()
                        while alwaysHitActive do
                            if not KillFunc then FindKillFunc() end
                            RunService.Heartbeat:Wait()
                        end
                    end))

                    -- MAIN LOOP
                    table.insert(_connections, task.spawn(function()
                        local attemptAccumulator = 0
                        local BASE_INTERVAL = 0.05
                        RunService.Heartbeat:Connect(function(deltaTime)
                            if not alwaysHitActive then return end
                            local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                            attemptAccumulator = attemptAccumulator + deltaTime
                            if attemptAccumulator < interval then return end
                            attemptAccumulator = 0

                            if hitbox2Active then
                                local target = GetSkid()
                                if target and target.Character then
                                    local part = target.Character:FindFirstChild("HumanoidRootPart")
                                    if part then
                                        safe(function()
                                            local ok = TryKill(part)
                                            if not ok then
                                                safe(KillFunc, part, true, part.Position)
                                            end
                                        end)
                                    end
                                end
                            end
                        end)
                    end))
                end)
            end

            -- initial loop start
            SoftResetLoops()

            -- connect respawn
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops) -- only refresh loops on respawn
                end)
            end
        end
    end
},

["Register Hit (Head)"] = {
    button = alwaysHit2Button,
    state = false,
    toggleFunction = function(state)
        alwaysHit2Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Headshots enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            local function GetSkid()
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                        if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                            return plr
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- KILLFUNC SYSTEM
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refreshes loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect existing connections
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- Restart watchdog & main loop
                task.spawn(function()
                    -- WATCHDOG
                    table.insert(_connections, task.spawn(function()
                        while alwaysHit2Active do
                            if not KillFunc then FindKillFunc() end
                            RunService.Heartbeat:Wait()
                        end
                    end))

                    -- MAIN LOOP
                    table.insert(_connections, task.spawn(function()
                        local attemptAccumulator = 0
                        local BASE_INTERVAL = 0.05
                        RunService.Heartbeat:Connect(function(deltaTime)
                            if not alwaysHit2Active then return end
                            local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                            attemptAccumulator = attemptAccumulator + deltaTime
                            if attemptAccumulator < interval then return end
                            attemptAccumulator = 0

                            if hitbox2Active then
                                local target = GetSkid()
                                if target and target.Character then
                                    local part = target.Character:FindFirstChild("Head")
                                    if part then
                                        safe(function()
                                            local ok = TryKill(part)
                                            if not ok then
                                                safe(KillFunc, part, true, part.Position)
                                            end
                                        end)
                                    end
                                end
                            end
                        end)
                    end))
                end)
            end

            -- initial loop start
            SoftResetLoops()

            -- connect respawn
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops) -- only refresh loops on respawn
                end)
            end
        end
    end
},

["Register Hit (All Body Parts)"] = {
    button = alwaysHit3Button,
    state = false,
    toggleFunction = function(state)
        alwaysHit3Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit",
                Text = "Cycling Body Hits Enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            ------------------------------------------------------------------
            -- GET NEAREST VALID TARGET
            ------------------------------------------------------------------
            local function GetSkid()
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        local backpack = plr:FindFirstChildOfClass("Backpack")
                        local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                        if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                            return plr
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- KILLFUNC SYSTEM
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local cycleIndex = 1
            local cycleOrder = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}

            local function GetNextR6Part(character)
                for i = 1, 6 do
                    local partName = cycleOrder[cycleIndex]
                    cycleIndex = cycleIndex % 6 + 1
                    local part = character:FindFirstChild(partName)
                    if part then return part end
                end
                return character:FindFirstChild("HumanoidRootPart")
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refreshes loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect existing connections
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- WATCHDOG
                table.insert(_connections, task.spawn(function()
                    while alwaysHit3Active do
                        if not KillFunc then FindKillFunc() end
                        RunService.Heartbeat:Wait()
                    end
                end))

                -- MAIN LOOP
                table.insert(_connections, task.spawn(function()
                    local attemptAccumulator = 0
                    local BASE_INTERVAL = 0.05
                    RunService.Heartbeat:Connect(function(deltaTime)
                        if not alwaysHit3Active then return end
                        local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                        attemptAccumulator = attemptAccumulator + deltaTime
                        if attemptAccumulator < interval then return end
                        attemptAccumulator = 0

                        if hitbox2Active then
                            local target = GetSkid()
                            if target and target.Character then
                                local part = GetNextR6Part(target.Character)
                                if part then
                                    safe(function()
                                        local ok = TryKill(part)
                                        if not ok then
                                            safe(KillFunc, part, true, part.Position)
                                        end
                                    end)
                                end
                            end
                        end
                    end)
                end))
            end

            -- initial loop start
            SoftResetLoops()

            -- connect respawn
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops)
                end)
            end
        end
    end
},

["Register Hit Duos (All Body Parts)"] = {
    button = duoAlwaysHit3Button,
    state = false,
    toggleFunction = function(state)
        duoAlwaysHit3Active = state

        if state then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Register Hit Duos",
                Text = "Cycling Body Hits Enabled!",
                Duration = 3
            })

            local plrs = game:GetService("Players")
            local lp = plrs.LocalPlayer
            local StarterGui = game:GetService("StarterGui")
            local RunService = game:GetService("RunService")

            if not lp then return end

            local _connections = {}
            local _respawnConn = nil

            ------------------------------------------------------------------
            -- GET NEAREST VALID TARGET
            ------------------------------------------------------------------
            local function GetSkid()
                local myTeamColor = lp.TeamColor
                for _, plr in pairs(plrs:GetPlayers()) do
                    if plr ~= lp and plr.Character then
                        if not (myTeamColor and plr.TeamColor and plr.TeamColor == myTeamColor) then
                            local backpack = plr:FindFirstChildOfClass("Backpack")
                            local hasBlade = (backpack and backpack:FindFirstChild("Blade")) or plr.Character:FindFirstChild("Blade")
                            if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                                return plr
                            end
                        end
                    end
                end
                return nil
            end

            ------------------------------------------------------------------
            -- ULTRA-STABLE KILLFUNC SYSTEM (AUTO RECOVERY)
            ------------------------------------------------------------------
            local lastStatus, KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil, nil

            local function Notify(t)
                pcall(function()
                    StarterGui:SetCore("SendNotification", {
                        Title = t.Title or "Status",
                        Text = t.Text or "",
                        Duration = t.Duration or 5
                    })
                end)
            end

            local function HardRescan()
                KillFunc, killSignatureFound, lastKillFuncPointer = nil, nil, nil
            end

            local function FindKillFunc()
                for _, v in pairs(getgc(false)) do
                    if type(v) == "function" then
                        local ok, env = pcall(getfenv, v)
                        if ok and env then
                            local scr = env.script
                            local firstScript = lp.PlayerScripts:GetChildren()[1]
                            local firstScriptName = firstScript and firstScript.Name or ""

                            if scr and tostring(scr) == firstScriptName then
                                local constants = debug.getconstants(v)
                                for _, c in pairs(constants) do
                                    if tostring(c) == "IIlIla" then
                                        if v ~= lastKillFuncPointer then
                                            killSignatureFound = nil
                                            lastKillFuncPointer = v
                                        end

                                        KillFunc = v

                                        if lastStatus ~= "found" then
                                            lastStatus = "found"
                                            Notify({
                                                Title = "KillFunc Status",
                                                Text = "KillFunc FOUND ✔",
                                                Duration = 6
                                            })
                                        end
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end

                if lastStatus ~= "notfound" then
                    lastStatus = "notfound"
                    Notify({
                        Title = "KillFunc Status",
                        Text = "KillFunc NOT FOUND ❌ — rescanning...",
                        Duration = 6
                    })
                end
                return false
            end

            local function safe(fn, ...)
                return pcall(fn, ...)
            end

            local cycleIndex = 1
            local cycleOrder = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}

            local function GetNextR6Part(character)
                for i = 1, 6 do
                    local partName = cycleOrder[cycleIndex]
                    cycleIndex = cycleIndex % 6 + 1
                    local part = character:FindFirstChild(partName)
                    if part then return part end
                end
                return character:FindFirstChild("HumanoidRootPart")
            end

            local function TryKill(part)
                if not KillFunc then return false end

                if killSignatureFound == 1 and safe(KillFunc, part, true, part.Position) then return true end
                if killSignatureFound == 2 and safe(KillFunc, part, part.Position, true) then return true end
                if killSignatureFound == 3 and safe(KillFunc, part, true) then return true end

                if safe(KillFunc, part, true, part.Position) then
                    if not killSignatureFound then killSignatureFound = 1 Notify({Title="KillFunc", Text="Signature #1 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, part.Position, true) then
                    if not killSignatureFound then killSignatureFound = 2 Notify({Title="KillFunc", Text="Signature #2 locked", Duration=5}) end
                    return true
                end
                if safe(KillFunc, part, true) then
                    if not killSignatureFound then killSignatureFound = 3 Notify({Title="KillFunc", Text="Signature #3 locked", Duration=5}) end
                    return true
                end

                HardRescan()
                FindKillFunc()
                return false
            end

            ------------------------------------------------------------------
            -- SOFT RESET (refresh loops on respawn only)
            ------------------------------------------------------------------
            local function SoftResetLoops()
                -- Disconnect old loops
                for _, c in pairs(_connections) do
                    pcall(function() c:Disconnect() end)
                end
                _connections = {}

                -- WATCHDOG
                table.insert(_connections, task.spawn(function()
                    while duoAlwaysHit3Active do
                        if not KillFunc then FindKillFunc() end
                        RunService.Heartbeat:Wait()
                    end
                end))

                -- MAIN LOOP
                table.insert(_connections, task.spawn(function()
                    local attemptAccumulator = 0
                    local BASE_INTERVAL = 0.05
                    RunService.Heartbeat:Connect(function(deltaTime)
                        if not duoAlwaysHit3Active then return end
                        local interval = math.clamp(BASE_INTERVAL / deltaTime, 0.03, 0.1)
                        attemptAccumulator = attemptAccumulator + deltaTime
                        if attemptAccumulator < interval then return end
                        attemptAccumulator = 0

                        if duoHitbox2Active then
                            local target = GetSkid()
                            if target and target.Character then
                                local part = GetNextR6Part(target.Character)
                                if part then
                                    safe(function()
                                        local ok = TryKill(part)
                                        if not ok then
                                            safe(KillFunc, part, true, part.Position)
                                        end
                                    end)
                                end
                            end
                        end
                    end)
                end))
            end

            -- start loops
            SoftResetLoops()

            -- respawn listener
            if not _respawnConn then
                _respawnConn = lp.CharacterAdded:Connect(function()
                    task.defer(SoftResetLoops)
                end)
            end
        end
    end
},

-- // hit body toggle  --

["Legit Auto Throw"] = {
button = extraButton,
state = false,
toggleFunction = function(state)
hitbox2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0 -- cooldown tracker
local equipCooldown = false

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw",
Text = state and "Legit throw enabled!" or "Legit throw disabled",
Duration = 3
})

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid")
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then
Track = Animator:LoadAnimation(Animation)
end
if not Track2 then
Track2 = Animator:LoadAnimation(Animation)
end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while hitbox2Active do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then
continue
end

if not hasToolEquipped() then continue end

bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget = nil
local bestDistance = math.huge

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

if humanoid and head and humanoid.Health > 0 and hasBlade then
local distance = (hrp.Position - camera.CFrame.Position).Magnitude
if distance < bestDistance then
bestTarget = head
bestDistance = distance
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait()

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- PERFECTLY SYNCED THROW (TRUE REALTIME AIM)
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
    lastThrowTime = tick()

    bestTargetForAimlock = bestTarget  -- still sync target for aimlock

    -- play animation normally
    playThrowAnimation()
    playThrowAnimation()

    -- DO NOT freeze crosshair here.
    -- crosshair keeps tracking during animation.

    task.delay(0.25, function()
        -- sync with physics so the throw reads the FINAL crosshairPos
        RunService.Heartbeat:Wait()

        if crosshairPos and bind and type(bind.Fire) == "function" then
            -- USE THE MOST RECENT, LIVE crosshairPos (DO NOT use any stored value)
            local firePos = crosshairPos

            pcall(function()
                bind:Fire("t", CFrame.new(firePos))
end)
end
end)
end
end
end)
end
end
},

["Legit Auto Throw (Duos)"] = {
button = extra2Button,
state = false,
toggleFunction = function(state)
duoHitbox2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0 -- cooldown tracker
local equipCooldown = false

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw Duos",
Text = state and "Legit throw duos enabled!" or "Legit throw duos disabled",
Duration = 3
})

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid")
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then
Track = Animator:LoadAnimation(Animation)
end
if not Track2 then
Track2 = Animator:LoadAnimation(Animation)
end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while duoHitbox2Active do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then
continue
end

if not hasToolEquipped() then continue end

bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget = nil
local bestDistance = math.huge
local localTeamColor = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))

if humanoid and head and humanoid.Health > 0 and hasBlade then
local distance = (hrp.Position - camera.CFrame.Position).Magnitude
if distance < bestDistance then
bestTarget = head
bestDistance = distance
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait()

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- PERFECTLY SYNCED THROW (TRUE REALTIME AIM)
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
    lastThrowTime = tick()

    bestTargetForAimlock = bestTarget  -- still sync target for aimlock

    -- play animation normally
    playThrowAnimation()
    playThrowAnimation()

    -- DO NOT freeze crosshair here.
    -- crosshair keeps tracking during animation.

    task.delay(0.25, function()
        -- sync with physics so the throw reads the FINAL crosshairPos
        RunService.Heartbeat:Wait()

        if crosshairPos and bind and type(bind.Fire) == "function" then
            -- USE THE MOST RECENT, LIVE crosshairPos (DO NOT use any stored value)
            local firePos = crosshairPos

            pcall(function()
                bind:Fire("t", CFrame.new(firePos))
end)
end
end)
end
end
end)
end
end
},

["Legit Auto Throw Duos V2"] = {
button = duoHit1Button,
state = false,
toggleFunction = function(state)
duoHit1Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0
local projectileSpeed = 270
local gravity = Workspace.Gravity or 196.2
local KillFunc
local equipCooldown = false

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw Duos V2",
Text = state and "Enabled!" or "Disabled!",
Duration = 3
})

-- improved KillFunc finder + robust caller with single notifications
local lastStatus = nil  -- "found" or "notfound"

local function FindKillFunc()
for i, v in pairs(getgc(false)) do
if type(v) == "function" then
local ok, env = pcall(getfenv, v)
if ok and env then
local scr = env.script
local firstScriptName = (lp.PlayerScripts:GetChildren()[1] and lp.PlayerScripts:GetChildren()[1].Name) or ""
if scr and tostring(scr) == firstScriptName then
local constants = debug.getconstants(v)
for _, c in pairs(constants) do
if tostring(c) == "IIlIla" then
KillFunc = v
if lastStatus ~= "found" then
lastStatus = "found"
StarterGui:SetCore("SendNotification", {
  Title = "KillFunc Status",
  Text = "KillFunc FOUND ✔",
  Duration = 6
})
end
return true
end
end
end
end
end
end

if lastStatus ~= "notfound" then
lastStatus = "notfound"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc NOT FOUND ❌ — Trying to detect...",
Duration = 6
})
end

return false
end

local killSignatureFound = nil
local function TryKill(part)
if not KillFunc then return false end

local function attempt(fn, ...)
local ok, _ = pcall(fn, ...)
return ok
end

if killSignatureFound == 1 and attempt(KillFunc, part, true, part.Position) then return true end
if killSignatureFound == 2 and attempt(KillFunc, part, part.Position, true) then return true end
if killSignatureFound == 3 and attempt(KillFunc, part, true) then return true end

if attempt(KillFunc, part, true, part.Position) then
if not killSignatureFound then
killSignatureFound = 1
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #1 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, part.Position, true) then
if not killSignatureFound then
killSignatureFound = 2
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #2 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, true) then
if not killSignatureFound then
killSignatureFound = 3
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #3 worked", Duration=5})
end
return true
end

KillFunc = nil
killSignatureFound = nil
pcall(FindKillFunc)
return false
end

-- background re-check
task.spawn(function()
while true do
if not KillFunc then
pcall(FindKillFunc)
end
task.wait(1)
end
end)

local function GetSkid()
local myTeamColor = lp.TeamColor
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
-- Exclude any player whose TeamColor equals your local player's.
if myTeamColor and plr.TeamColor and (plr.TeamColor == myTeamColor) then
-- This is your teammate; skip.
else
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
return plr
end
end
end
end
return nil
end

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
pcall(GetKillFunc)
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid", 2)
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then Track = Animator:LoadAnimation(Animation) end
if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while duoHit1Active do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end
if not hasToolEquipped() then continue end

bind = lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget, bestDistance = nil, math.huge
local localTeamColor = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if humanoid and head and humanoid.Health > 0 and hasBlade then
local dist = (hrp.Position - camera.CFrame.Position).Magnitude
if dist < bestDistance then
bestDistance = dist
bestTarget = head
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait(0.1)

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- ==========================================================
-- PERFECTLY SYNCED THROW
-- ==========================================================
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
lastThrowTime = tick()

bestTargetForAimlock = bestTarget   -- sync target

-- LOCK CROSSHAIR EXACTLY to real position (no smoothing delay)
if bestTargetForAimlock and bestTargetForAimlock.Parent then
crosshairPos = bestTargetForAimlock.Position
end

playThrowAnimation()
playThrowAnimation()

task.wait(0.25)

if crosshairPos and bind and type(bind.Fire) == "function" then
pcall(function()
bind:Fire("t", CFrame.new(crosshairPos))
end)
end
end

-- main kill loop
task.spawn(function()
bind = lp.PlayerScripts:FindFirstChild("Event") or bind
local refreshTimer = tick()
while tick() - refreshTimer < 0.5 do
if not duoHit1Active then break end
if not KillFunc then
pcall(FindKillFunc)
end
local targetPlayer = GetSkid()
if not (targetPlayer and targetPlayer.Character) then
task.wait()
continue
end
local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
local part = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
if not (humanoid and part) then
task.wait()
continue
end
if KillFunc then
local ok = pcall(function()
local suc = TryKill(part)
if not suc then
pcall(function()
KillFunc(part, true, part.Position)
end)
end
end)
if not ok then KillFunc = nil end
end
task.wait(0.03)
end
end)
end
end)
end
end
},

["Legit Auto Throw Duos V2 (Head)"] = {
button = duoHit2Button,
state = false,
toggleFunction = function(state)
duoHit2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0
local projectileSpeed = 270
local gravity = Workspace.Gravity or 196.2
local KillFunc
local equipCooldown = false

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw Duos V2 Head",
Text = state and "Enabled!" or "Disabled!",
Duration = 3
})

-- improved KillFunc finder + robust caller with single notifications
local lastStatus = nil  -- "found" or "notfound"

local function FindKillFunc()
for i, v in pairs(getgc(false)) do
if type(v) == "function" then
local ok, env = pcall(getfenv, v)
if ok and env then
local scr = env.script
local firstScriptName = (lp.PlayerScripts:GetChildren()[1] and lp.PlayerScripts:GetChildren()[1].Name) or ""
if scr and tostring(scr) == firstScriptName then
local constants = debug.getconstants(v)
for _, c in pairs(constants) do
if tostring(c) == "IIlIla" then
KillFunc = v
if lastStatus ~= "found" then
lastStatus = "found"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc FOUND ✔",
Duration = 6
})
end
return true
end
end
end
end
end
end

if lastStatus ~= "notfound" then
lastStatus = "notfound"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc NOT FOUND ❌ — Trying to detect...",
Duration = 6
})
end

return false
end

local killSignatureFound = nil
local function TryKill(part)
if not KillFunc then return false end

local function attempt(fn, ...)
local ok, _ = pcall(fn, ...)
return ok
end

if killSignatureFound == 1 and attempt(KillFunc, part, true, part.Position) then return true end
if killSignatureFound == 2 and attempt(KillFunc, part, part.Position, true) then return true end
if killSignatureFound == 3 and attempt(KillFunc, part, true) then return true end

if attempt(KillFunc, part, true, part.Position) then
if not killSignatureFound then
killSignatureFound = 1
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #1 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, part.Position, true) then
if not killSignatureFound then
killSignatureFound = 2
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #2 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, true) then
if not killSignatureFound then
killSignatureFound = 3
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #3 worked", Duration=5})
end
return true
end

KillFunc = nil
killSignatureFound = nil
pcall(FindKillFunc)
return false
end

-- background re-check
task.spawn(function()
while true do
if not KillFunc then
pcall(FindKillFunc)
end
task.wait(1)
end
end)

local function GetSkid()
local myTeamColor = lp.TeamColor
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
-- Exclude any player whose TeamColor equals your local player's.
if myTeamColor and plr.TeamColor and (plr.TeamColor == myTeamColor) then
-- This is your teammate; skip.
else
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
return plr
end
end
end
end
return nil
end

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
pcall(GetKillFunc)
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid", 2)
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then Track = Animator:LoadAnimation(Animation) end
if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while duoHit2Active do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end
if not hasToolEquipped() then continue end

bind = lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget, bestDistance = nil, math.huge
local localTeamColor = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= localTeamColor and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if humanoid and head and humanoid.Health > 0 and hasBlade then
local dist = (hrp.Position - camera.CFrame.Position).Magnitude
if dist < bestDistance then
bestDistance = dist
bestTarget = head
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait(0.1)

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- ==========================================================
-- PERFECTLY SYNCED THROW
-- ==========================================================
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
lastThrowTime = tick()

bestTargetForAimlock = bestTarget   -- sync target

-- LOCK CROSSHAIR EXACTLY to real position (no smoothing delay)
if bestTargetForAimlock and bestTargetForAimlock.Parent then
crosshairPos = bestTargetForAimlock.Position
end

playThrowAnimation()
playThrowAnimation()

task.wait(0.25)

if crosshairPos and bind and type(bind.Fire) == "function" then
pcall(function()
bind:Fire("t", CFrame.new(crosshairPos))
end)
end
end

-- main kill loop
task.spawn(function()
bind = lp.PlayerScripts:FindFirstChild("Event") or bind
local refreshTimer = tick()
while tick() - refreshTimer < 0.5 do
if not duoHit2Active then break end
if not KillFunc then
pcall(FindKillFunc)
end
local targetPlayer = GetSkid()
if not (targetPlayer and targetPlayer.Character) then
task.wait()
continue
end
local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
local part = targetPlayer.Character:FindFirstChild("Head")
if not (humanoid and part) then
task.wait()
continue
end
if KillFunc then
local ok = pcall(function()
local suc = TryKill(part)
if not suc then
pcall(function()
KillFunc(part, true, part.Position)
end)
end
end)
if not ok then KillFunc = nil end
end
task.wait(0.03)
end
end)
end
end)
end
end
},

["Legit Auto Throw V2"] = {
button = anotherButton,
state = false,
toggleFunction = function(state)
boxActive = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0
local projectileSpeed = 270
local gravity = Workspace.Gravity or 196.2
local KillFunc
local equipCooldown = false

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw",
Text = state and "Enabled!" or "Disabled!",
Duration = 3
})

-- improved KillFunc finder + robust caller with single notifications
local lastStatus = nil  -- "found" or "notfound"

local function FindKillFunc()
for i, v in pairs(getgc(false)) do
if type(v) == "function" then
local ok, env = pcall(getfenv, v)
if ok and env then
local scr = env.script
local firstScriptName = (lp.PlayerScripts:GetChildren()[1] and lp.PlayerScripts:GetChildren()[1].Name) or ""
if scr and tostring(scr) == firstScriptName then
local constants = debug.getconstants(v)
for _, c in pairs(constants) do
if tostring(c) == "IIlIla" then
KillFunc = v
if lastStatus ~= "found" then
lastStatus = "found"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc FOUND ✔",
Duration = 6
})
end
return true
end
end
end
end
end
end

if lastStatus ~= "notfound" then
lastStatus = "notfound"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc NOT FOUND ❌ — Trying to detect...",
Duration = 6
})
end

return false
end

local killSignatureFound = nil
local function TryKill(part)
if not KillFunc then return false end

local function attempt(fn, ...)
local ok, _ = pcall(fn, ...)
return ok
end

if killSignatureFound == 1 and attempt(KillFunc, part, true, part.Position) then return true end
if killSignatureFound == 2 and attempt(KillFunc, part, part.Position, true) then return true end
if killSignatureFound == 3 and attempt(KillFunc, part, true) then return true end

if attempt(KillFunc, part, true, part.Position) then
if not killSignatureFound then
killSignatureFound = 1
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #1 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, part.Position, true) then
if not killSignatureFound then
killSignatureFound = 2
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #2 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, true) then
if not killSignatureFound then
killSignatureFound = 3
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #3 worked", Duration=5})
end
return true
end

KillFunc = nil
killSignatureFound = nil
pcall(FindKillFunc)
return false
end

-- background re-check
task.spawn(function()
while true do
if not KillFunc then
pcall(FindKillFunc)
end
task.wait(1)
end
end)

local function GetSkid()
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local hum = plr.Character:FindFirstChildOfClass("Humanoid")
if hasBlade and hum and hum.Health > 0 then
return plr
end
end
end
return nil
end

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
pcall(GetKillFunc)
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid", 2)
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then Track = Animator:LoadAnimation(Animation) end
if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while boxActive do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end
if not hasToolEquipped() then continue end

bind = lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget, bestDistance = nil, math.huge

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if humanoid and head and humanoid.Health > 0 and hasBlade then
local dist = (hrp.Position - camera.CFrame.Position).Magnitude
if dist < bestDistance then
bestDistance = dist
bestTarget = head
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait(0.1)

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- ==========================================================
-- PERFECTLY SYNCED THROW
-- ==========================================================
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
lastThrowTime = tick()

bestTargetForAimlock = bestTarget   -- sync target

-- LOCK CROSSHAIR EXACTLY to real position (no smoothing delay)
if bestTargetForAimlock and bestTargetForAimlock.Parent then
crosshairPos = bestTargetForAimlock.Position
end

playThrowAnimation()
playThrowAnimation()

task.wait(0.25)

if crosshairPos and bind and type(bind.Fire) == "function" then
pcall(function()
bind:Fire("t", CFrame.new(crosshairPos))
end)
end
end

-- main kill loop
task.spawn(function()
bind = lp.PlayerScripts:FindFirstChild("Event") or bind
local refreshTimer = tick()
while tick() - refreshTimer < 0.5 do
if not boxActive then break end
if not KillFunc then
pcall(FindKillFunc)
end
local targetPlayer = GetSkid()
if not (targetPlayer and targetPlayer.Character) then
task.wait()
continue
end
local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
local part = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
if not (humanoid and part) then
task.wait()
continue
end
if KillFunc then
local ok = pcall(function()
local suc = TryKill(part)
if not suc then
pcall(function()
KillFunc(part, true, part.Position)
end)
end
end)
if not ok then KillFunc = nil end
end
task.wait(0.03)
end
end)
end
end)
end
end
},

["Legit Auto Throw V2 (Head)"] = {
button = headHitButton,
state = false,
toggleFunction = function(state)
box2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local bind
local lastThrowTime = 0
local projectileSpeed = 270
local gravity = Workspace.Gravity or 196.2
local KillFunc
local equipCooldown = false

StarterGui:SetCore("SendNotification", {
Title = "Legit Auto Throw V2 Head",
Text = state and "Enabled!" or "Disabled!",
Duration = 3
})

-- improved KillFunc finder + robust caller with single notifications
local lastStatus = nil  -- "found" or "notfound"

local function FindKillFunc()
for i, v in pairs(getgc(false)) do
if type(v) == "function" then
local ok, env = pcall(getfenv, v)
if ok and env then
local scr = env.script
local firstScriptName = (lp.PlayerScripts:GetChildren()[1] and lp.PlayerScripts:GetChildren()[1].Name) or ""
if scr and tostring(scr) == firstScriptName then
local constants = debug.getconstants(v)
for _, c in pairs(constants) do
if tostring(c) == "IIlIla" then
KillFunc = v
if lastStatus ~= "found" then
lastStatus = "found"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc FOUND ✔",
Duration = 6
})
end
return true
end
end
end
end
end
end

if lastStatus ~= "notfound" then
lastStatus = "notfound"
StarterGui:SetCore("SendNotification", {
Title = "KillFunc Status",
Text = "KillFunc NOT FOUND ❌ — Trying to detect...",
Duration = 6
})
end

return false
end

local killSignatureFound = nil
local function TryKill(part)
if not KillFunc then return false end

local function attempt(fn, ...)
local ok, _ = pcall(fn, ...)
return ok
end

if killSignatureFound == 1 and attempt(KillFunc, part, true, part.Position) then return true end
if killSignatureFound == 2 and attempt(KillFunc, part, part.Position, true) then return true end
if killSignatureFound == 3 and attempt(KillFunc, part, true) then return true end

if attempt(KillFunc, part, true, part.Position) then
if not killSignatureFound then
killSignatureFound = 1
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #1 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, part.Position, true) then
if not killSignatureFound then
killSignatureFound = 2
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #2 worked", Duration=5})
end
return true
end
if attempt(KillFunc, part, true) then
if not killSignatureFound then
killSignatureFound = 3
StarterGui:SetCore("SendNotification", {Title="KillFunc", Text="call-signature #3 worked", Duration=5})
end
return true
end

KillFunc = nil
killSignatureFound = nil
pcall(FindKillFunc)
return false
end

-- background re-check
task.spawn(function()
while true do
if not KillFunc then
pcall(FindKillFunc)
end
task.wait(1)
end
end)

local function GetSkid()
for _, plr in pairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local hum = plr.Character:FindFirstChildOfClass("Humanoid")
if hasBlade and hum and hum.Health > 0 then
return plr
end
end
end
return nil
end

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

local function resetThrowSystem()
if Track and Track.IsPlaying then Track:Stop() end
if Track2 and Track2.IsPlaying then Track2:Stop() end
Track, Track2, Animator = nil, nil, nil
lastThrowTime = 0
pcall(GetKillFunc)
end

local function hasToolEquipped()
if not lp.Character then return false end
for _, item in ipairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "Blade" or item.Name == "blade") then
return true
end
end
return false
end

local function setupAnimator(character)
local hum = character:WaitForChild("Humanoid", 2)
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
character.ChildRemoved:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
resetThrowSystem()
end
end)
end

local function onToolEquipped(tool)
if tool.Name == "Blade" or tool.Name == "blade" then
resetThrowSystem()
equipCooldown = true
task.delay(0.25, function()
equipCooldown = false
end)
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end
end
end

local function ensureTrack()
if not Animator then
local hum = lp.Character and lp.Character:FindFirstChild("Humanoid")
if not hum then return end
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
end
if not Track then Track = Animator:LoadAnimation(Animation) end
if not Track2 then Track2 = Animator:LoadAnimation(Animation) end
end

local function playThrowAnimation()
ensureTrack()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

local function hookCharacter(char)
setupAnimator(char)

-- ALWAYS re-hook tool detection every respawn
char.ChildAdded:Connect(function(child)
if child:IsA("Tool") and (child.Name == "Blade" or child.Name == "blade") then
onToolEquipped(child)
end
end)
end

if state then
if lp.Character then hookCharacter(lp.Character) end
lp.CharacterAdded:Connect(hookCharacter)
lp.CharacterRemoving:Connect(resetThrowSystem)
lp.Character.ChildAdded:Connect(onToolEquipped)

spawn(function()
while box2Active do
task.wait()

if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end
if not hasToolEquipped() then continue end

bind = lp.PlayerScripts:FindFirstChild("Event") or bind
if not bind then continue end

local camera = Workspace.CurrentCamera
local bestTarget, bestDistance = nil, math.huge

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local humanoid = plr.Character:FindFirstChild("Humanoid")
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if humanoid and head and humanoid.Health > 0 and hasBlade then
local dist = (hrp.Position - camera.CFrame.Position).Magnitude
if dist < bestDistance then
bestDistance = dist
bestTarget = head
end
end
end
end

-- ==========================================================
-- ULTRA-SMOOTH REAL-TIME AIMLOCK (NO PREDICTION, NO OFFSET)
-- ==========================================================
local crosshairPos = nil
local crosshairPart = nil
local trackConn = nil
local bestTargetForAimlock = nil

local SMOOTHNESS = 0.08  -- unused now but kept so structure stays intact

-- ==========================================================
-- AUTO-CLEAR CROSSHAIR ON LOCALPLAYER DEATH OR RESPAWN
-- ==========================================================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

local function stopCrosshairTracking()
if trackConn then
trackConn:Disconnect()
trackConn = nil
end
if crosshairPart then
crosshairPart:Destroy()
crosshairPart = nil
end
crosshairPos = nil
bestTargetForAimlock = nil
end

local function monitorLocalDeath()
task.spawn(function()
while true do
task.wait(0.1)

if not lp.Character then
stopCrosshairTracking()
continue
end

local hum = lp.Character:FindFirstChild("Humanoid")
if hum and hum.Health <= 0 then
stopCrosshairTracking()
end
end
end)
end

monitorLocalDeath()

local function ensureCrosshairVisual()
if crosshairPart and crosshairPart.Parent then return end

local p = Instance.new("Part")
p.Anchored = true
p.CanCollide = false
p.Shape = Enum.PartType.Ball
p.Material = Enum.Material.Neon
p.Color = Color3.new(1, 0, 0)
p.Size = Vector3.new(0.35, 0.35, 0.35)
p.Parent = workspace

crosshairPart = p
end

local function startAimlockLoop()
ensureCrosshairVisual()

if trackConn then return end

trackConn = RunService.RenderStepped:Connect(function(dt)
local t = bestTargetForAimlock

-- delete crosshair if target is dead
if not t or not t.Parent or (t.Parent:FindFirstChild("Humanoid") and t.Parent.Humanoid.Health <= 0) then
stopCrosshairTracking()
ensureCrosshairVisual()
return
end

-- EXACT HEAD POSITION (NO OFFSET)
local head = t.Parent:FindFirstChild("Head") or t
local raw = head.Position

-- ==========================================
-- ADAPTIVE ZERO-DELAY BUTTER SMOOTH SYSTEM
-- ==========================================
if not crosshairPos then
crosshairPos = raw
else
local delta = (raw - crosshairPos).Magnitude

if delta > 1 then
-- fast target movement → SNAP instantly (no delay)
crosshairPos = raw
else
-- small micro movement → buttery smoothing
crosshairPos = crosshairPos:Lerp(raw, 0.35)
end
end

if crosshairPart then
crosshairPart.Transparency = 0
crosshairPart.Position = crosshairPos
end
end)
end

startAimlockLoop()

-- ==========================================================
-- PERFECTLY SYNCED THROW
-- ==========================================================
if not equipCooldown and bestTarget and tick() - lastThrowTime >= 1 then
lastThrowTime = tick()

bestTargetForAimlock = bestTarget   -- sync target

-- LOCK CROSSHAIR EXACTLY to real position (no smoothing delay)
if bestTargetForAimlock and bestTargetForAimlock.Parent then
crosshairPos = bestTargetForAimlock.Position
end

playThrowAnimation()
playThrowAnimation()

task.wait(0.25)

if crosshairPos and bind and type(bind.Fire) == "function" then
pcall(function()
bind:Fire("t", CFrame.new(crosshairPos))
end)
end
end

-- main kill loop
task.spawn(function()
bind = lp.PlayerScripts:FindFirstChild("Event") or bind
local refreshTimer = tick()
while tick() - refreshTimer < 0.5 do
if not box2Active then break end
if not KillFunc then
pcall(FindKillFunc)
end
local targetPlayer = GetSkid()
if not (targetPlayer and targetPlayer.Character) then
task.wait()
continue
end
local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
local part = targetPlayer.Character:FindFirstChild("Head")
if not (humanoid and part) then
task.wait()
continue
end
if KillFunc then
local ok = pcall(function()
local suc = TryKill(part)
if not suc then
pcall(function()
KillFunc(part, true, part.Position)
end)
end
end)
if not ok then KillFunc = nil end
end
task.wait(0.03)
end
end)
end
end)
end
end
},

["Force Players to Kill (Secret)"] = {
button = forceButton,
state = false,
toggleFunction = function(state)
forceActive = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Secrecy 😈",
Text = "Force rape enabled! rape them lol.",
Duration = 3;
})

spawn(function()
while forceActive do
game:GetService("ReplicatedStorage").RemoteEvent:FireServer(16, "secret")
wait()
end
end)
end
end
},

["Force Players to Kill (Public)"] = {
button = force2Button,
state = false,
toggleFunction = function(state)
force2Active = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Publicity ??",
Text = "Force rape enabled! rape  them lol.",
Duration = 3;
})

spawn(function()
while force2Active do
game:GetService("ReplicatedStorage").RemoteEvent:FireServer(16, "public")
wait()
end
end)
end
end
},

["Auto Throw Bulb V2"] = {
button = bulb3Button,
state = false,
toggleFunction = function(state)
bulb3Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb3Active do
task.wait(0)

if not boxActive then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb V2 Head"] = {
button = bulb4Button,
state = false,
toggleFunction = function(state)
bulb4Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb4Active do
task.wait(0)

if not box2Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos V2"] = {
button = bulbDuo1Button,
state = false,
toggleFunction = function(state)
bulbDuo1Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbDuo1Active do
task.wait(0)

-- Only run if duo throw is active
if not duoHit1Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos V2 Head"] = {
button = bulbDuo2Button,
state = false,
toggleFunction = function(state)
bulbDuo2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbDuo2Active do
task.wait(0)

-- Only run if duo throw is active
if not duoHit2Active then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then

local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Track
local Track2
local Animator

-- setup animator properly
local hum = lp.Character:FindFirstChild("Humanoid")
if hum then
Animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
Track = Animator:LoadAnimation(Animation)
Track2 = Animator:LoadAnimation(Animation)
end

local function playThrowAnimation()
if Track then Track:Play(5, 10, 2) end
if Track2 then Track2:Play(5, 10, 2) end
end

-- play
playThrowAnimation()
playThrowAnimation()

task.wait(0.30)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.8)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb"] = {
button = bulb2Button,
state = false,
toggleFunction = function(state)
bulb2Active = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb",
Text = state and "AT Bulb enabled! Automatic darkness." or "AT Bulb disabled.",
Duration = 3
})

if state then
spawn(function()
while bulb2Active do
task.wait(0)

if not hitbox2Active and not (boxActive and box2Active) then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Detect if ANY player (not localplayer) has a blade equipped or in backpack
local validEnemyFound = false
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
local humanoid = plr.Character:FindFirstChild("Humanoid")
if hasBlade and humanoid and humanoid.Health > 0 then
validEnemyFound = true
break
end
end
end

-- If no valid blade enemy exists, throw at bulb
if not validEnemyFound then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then
-- Play throw animation
local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Humanoid = lp.Character:FindFirstChild("Humanoid")
if Humanoid then
local Animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)
local Track = Animator:LoadAnimation(Animation)
Track:Play(5, 10, 2)
local Track2 = Animator:LoadAnimation(Animation)
Track:Play(5, 10, 2)
end

-- Fire at bulb
task.wait(0.25)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.7)
end
end
end
end
end)
end
end
},

["Auto Throw Bulb Duos"] = {
button = bulbButton,
state = false,
toggleFunction = function(state)
bulbActive = state
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local lp = Players.LocalPlayer
local bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")

StarterGui:SetCore("SendNotification", {
Title = "Auto Throw Bulb Duos",
Text = state and "AT Bulb Duos enabled! Automatic darkness." or "AT Bulb Duos disabled.",
Duration = 3
})

if state then
spawn(function()
while bulbActive do
task.wait(0)

-- Only run if duo throw is active
if not duoHitbox2Active and not (duoHit1Active and duoHit2Active) then continue end
if not lp.Character or not lp.Character:FindFirstChild("Humanoid") or lp.Character.Humanoid.Health <= 0 then continue end

if not bind then
bind = lp:FindFirstChild("PlayerScripts") and lp.PlayerScripts:FindFirstChild("Event")
if not bind then continue end
end

-- Enemy blade-user detection with TeamColor check (duos logic)
local hasEnemy = false
local myTeam = lp.TeamColor

for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= lp and plr.TeamColor ~= myTeam and plr.Character then
local backpack = plr:FindFirstChildOfClass("Backpack")
local hasBlade = plr.Character:FindFirstChild("Blade") or (backpack and backpack:FindFirstChild("Blade"))
if hasBlade and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
hasEnemy = true
break
end
end
end

-- Throw at bulb if NO valid enemies found
if not hasEnemy then
local lightBulb = Workspace:FindFirstChild("light")
if lightBulb then
local hasTool = false
for _, item in pairs(lp.Character:GetChildren()) do
if item:IsA("Tool") and (item.Name == "blade" or item.Name == "Blade") then
hasTool = true
break
end
end

if hasTool then
local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://944050359"
local Humanoid = lp.Character:FindFirstChild("Humanoid")
if Humanoid then
local Animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)
local Track = Animator:LoadAnimation(Animation)
Track:Play(5, 10, 2)
local Track2 = Animator:LoadAnimation(Animation)
Track:Play(5, 10, 2)
end

task.wait(0.25)
bind:Fire("t", lightBulb.CFrame)
task.wait(0.7)
end
end
end
end
end)
end
end
},

["Head/Body Semi"] = {
button = bodyButton,
state = false,
toggleFunction = function(state)
bodyActive = state

if state then
_G.HeadSize = 5
_G.HumanoidRootPartSize = 5
_G.HitboxExpandEnabled = true

-- Head loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
if head then
head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
head.Transparency = 1
head.BrickColor = BrickColor.new("Really blue")
head.Material = "Neon"
head.CanCollide = true
end
end)
end
end
end
end)
end)

-- HRP loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if hrp then
hrp.Size = Vector3.new(_G.HumanoidRootPartSize, _G.HumanoidRootPartSize, _G.HumanoidRootPartSize)
hrp.Transparency = 1
hrp.BrickColor = BrickColor.new("Really blue")
hrp.Material = "Neon"
hrp.CanCollide = false
end
end)
end
end
end
end)
end)

else
_G.HitboxExpandEnabled = false

-- Reset sizes
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if head then
head.Size = Vector3.new(2, 1, 1)
head.Transparency = 0
head.BrickColor = BrickColor.new("Medium stone grey")
head.Material = Enum.Material.Plastic
head.CanCollide = true
end
if hrp then
hrp.Size = Vector3.new(2, 2, 1)
hrp.Transparency = 0
hrp.BrickColor = BrickColor.new("Medium stone grey")
hrp.Material = Enum.Material.Plastic
hrp.CanCollide = true
end
end)
end
end
end
end
},

["Hitbox Expander"] = {
button = expanderButton,
state = false,
toggleFunction = function(state)
expanderActive = state

if state then
_G.HeadSize = 5
_G.HumanoidRootPartSize = 5
_G.HitboxExpandEnabled = true

-- Head loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
if head then
head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
head.Transparency = 1
head.BrickColor = BrickColor.new("Really blue")
head.Material = "Neon"
head.CanCollide = false
end
end)
end
end
end
end)
end)

-- HRP loop
spawn(function()
game:GetService('RunService').RenderStepped:Connect(function()
if _G.HitboxExpandEnabled then
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if hrp then
hrp.Size = Vector3.new(_G.HumanoidRootPartSize, _G.HumanoidRootPartSize, _G.HumanoidRootPartSize)
hrp.Transparency = 1
hrp.BrickColor = BrickColor.new("Really blue")
hrp.Material = "Neon"
hrp.CanCollide = false
end
end)
end
end
end
end)
end)

else
_G.HitboxExpandEnabled = false

-- Reset sizes
for _, v in next, game:GetService('Players'):GetPlayers() do
if v ~= game:GetService('Players').LocalPlayer then
pcall(function()
local head = v.Character and v.Character:FindFirstChild("Head")
local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart")
if head then
head.Size = Vector3.new(2, 1, 1)
head.Transparency = 0
head.BrickColor = BrickColor.new("Medium stone grey")
head.Material = Enum.Material.Plastic
head.CanCollide = true
end
if hrp then
hrp.Size = Vector3.new(2, 2, 1)
hrp.Transparency = 0
hrp.BrickColor = BrickColor.new("Medium stone grey")
hrp.Material = Enum.Material.Plastic
hrp.CanCollide = true
end
end)
end
end
end
end
},

["Kill Aura"] = {
button = killAuraButton,
state = false,
toggleFunction = function(state)
killAuraActive = state
if state then

game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Kill Aura",
Text = "Kill aura enabled! Any contact will result in the opponent's death.",
Duration = 3;
})

local connections = getgenv().configs and getgenv().configs.connection
if connections then
local Disable = configs.Disable
for i, v in connections do
v:Disconnect()
end
Disable:Fire()
Disable:Destroy()
table.clear(configs)
end

local Disable = Instance.new("BindableEvent")
getgenv().configs = {
connections = {},
Disable = Disable,
Size = Vector3.new(16, 16, 16),
DeathCheck = true
}

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local lp = Players.LocalPlayer
local Run = true
local Ignorelist = OverlapParams.new()
Ignorelist.FilterType = Enum.RaycastFilterType.Include

local function getchar(plr)
local plr = plr or lp
return plr.Character
end

local function gethumanoid(plr)
local char = plr:IsA("Model") and plr or getchar(plr)
if char then
return char:FindFirstChildWhichIsA("Humanoid")
end
end

local function IsAlive(Humanoid)
return Humanoid and Humanoid.Health > 0
end

local function GetTouchInterest(Tool)
return Tool and Tool:FindFirstChildWhichIsA("TouchTransmitter", true)
end

local function GetCharacters(LocalPlayerChar)
local Characters = {}
for i, v in Players:GetPlayers() do
table.insert(Characters, getchar(v))
end
table.remove(Characters, table.find(Characters, LocalPlayerChar))
return Characters
end

local function Attack(Tool, TouchPart, ToTouch)
if Tool:IsDescendantOf(workspace) then
Tool:Activate()
firetouchinterest(TouchPart, ToTouch, 1)
firetouchinterest(TouchPart, ToTouch, 0)
end
end

table.insert(getgenv().configs.connections, Disable.Event:Connect(function()
Run = false
end))

spawn(function()
while Run and killAuraActive do
local char = getchar()
if IsAlive(gethumanoid(char)) then
local Tool = char and char:FindFirstChildWhichIsA("Tool")
local TouchInterest = Tool and GetTouchInterest(Tool)

if TouchInterest then
local TouchPart = TouchInterest.Parent
local Characters = GetCharacters(char)
Ignorelist.FilterDescendantsInstances = Characters
local InstancesInBox = workspace:GetPartBoundsInBox(TouchPart.CFrame, TouchPart.Size + getgenv().configs.Size, Ignorelist)

for i, v in InstancesInBox do
local Character = v:FindFirstAncestorWhichIsA("Model")

if table.find(Characters, Character) then
if getgenv().configs.DeathCheck then
if IsAlive(gethumanoid(Character)) then
Attack(Tool, TouchPart, v)
end
else
Attack(Tool, TouchPart, v)
end
end
end
end
end
RunService.Heartbeat:Wait()
end
end)
else
if getgenv().configs and getgenv().configs.Disable then
getgenv().configs.Disable:Fire()
end
end
end
},

["Auto Reach"] = {
button = reachButton,
state = false,
toggleFunction = function(state)
reachActive = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Auto Reach",
Text = "Auto reach enabled! Compatible with Headless now.",
Duration = 3;
})

stopFireTap()

local function runReach()
task.spawn(function()
local SCAN_RANGE  = 4
local BEHIND_DIST = 1
local SCAN_DELAY  = 0

local speaker = Players.LocalPlayer

while reachActive do
task.wait(SCAN_DELAY)

local character = speaker.Character
if not character then continue end

local tool = tools(speaker)
if not tool then continue end

local myRoot = character:FindFirstChild("HumanoidRootPart")
if not myRoot then continue end

local found = false

for _, p in ipairs(Players:GetPlayers()) do
if p ~= speaker and p.Character and playerHasBlade(p) then
local targetRoot = p.Character:FindFirstChild("HumanoidRootPart")
local hum = p.Character:FindFirstChildOfClass("Humanoid")
if targetRoot and hum and hum.Health > 0 then
local dist = (myRoot.Position - targetRoot.Position).Magnitude
if dist <= SCAN_RANGE then
attachBehind(speaker, p, BEHIND_DIST)
fireTap()
found = true
break
end
end
end
end

if not found then
fireTapRunning = false
end
end
end)
end

runReach()

Players.LocalPlayer.CharacterAdded:Connect(function()
if reachActive then
task.wait(1)
runReach()
stopFireTap()
end
end)
end
end
},

["Auto Reach Duos"] = {
button = reach2Button,
state = false,
toggleFunction = function(state)
reach2Active = state

if state then
game:GetService("StarterGui"):SetCore("SendNotification", {
Title = "Auto Reach Duos",
Text = "Auto reach for duos enabled! Compatible with Headless now.",
Duration = 3;
})

stopFireTap()

local function runReachDuos()
task.spawn(function()
local SCAN_RANGE  = 4
local BEHIND_DIST = 1
local SCAN_DELAY  = 0

local speaker = Players.LocalPlayer

while reach2Active do
task.wait(SCAN_DELAY)

local character = speaker.Character
if not character then continue end

local tool = tools(speaker)
if not tool then continue end

local myRoot = character:FindFirstChild("HumanoidRootPart")
if not myRoot then continue end

local found = false

for _, p in ipairs(Players:GetPlayers()) do
if p ~= speaker and p.Character and playerHasBlade(p) then
local speakerTeamColor = speaker.TeamColor
local targetTeamColor = p.TeamColor

if speakerTeamColor and targetTeamColor and speakerTeamColor == targetTeamColor then
continue
end

local targetRoot = p.Character:FindFirstChild("HumanoidRootPart")
local hum = p.Character:FindFirstChildOfClass("Humanoid")
if targetRoot and hum and hum.Health > 0 then
local dist = (myRoot.Position - targetRoot.Position).Magnitude
if dist <= SCAN_RANGE then
attachBehind(speaker, p, BEHIND_DIST)
fireTap()
found = true
break
end
end
end
end

if not found then
fireTapRunning = false
end
end
end)
end

runReachDuos()

Players.LocalPlayer.CharacterAdded:Connect(function()
if reach2Active then
task.wait(1)
runReachDuos()
stopFireTap()
end
end)
end
end
},

["Full Bright"] = {
button = fullBrightButton,
state = false,
toggleFunction = function(state)
fullBrightActive = state
local Lighting = game:GetService("Lighting")

if state then
Lighting.Brightness = 2
Lighting.ClockTime = 14
Lighting.FogEnd = 100000
Lighting.GlobalShadows = false
Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
else
-- Restore default Lighting settings when toggled OFF
Lighting.Brightness = 1
Lighting.ClockTime = 12
Lighting.FogEnd = 1000
Lighting.GlobalShadows = true
Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
end
end
}
}

-- Button Toggle Function
local function toggleButtonState(featureName)
local feature = features[featureName]
if feature then
feature.state = not feature.state  -- Toggle the state
feature.button.Text = featureName .. (feature.state and ": ON" or ": OFF")
feature.button.BackgroundColor3 = feature.state and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(40, 40, 40)

-- Call the specific toggle function for the feature
feature.toggleFunction(feature.state)
end
end

-- Connect buttons to toggle function
for featureName, data in pairs(features) do
data.button.MouseButton1Click:Connect(function()
toggleButtonState(featureName)
end)
end

-- Tab Switching
mainTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = true
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = false
end)

settingsTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = true
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = false
end)

featuresTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = true
aboutTab.Visible = false
detailsTab.Visible = false
end)

aboutTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = true
detailsTab.Visible = false
end)

detailsTabButton.MouseButton1Click:Connect(function()
mainTab.Visible = false
settingsTab.Visible = false
featuresTab.Visible = false
aboutTab.Visible = false
detailsTab.Visible = true
end)

-- Notification Pop-up (Smooth & Aesthetic)
local popupFrame = Instance.new("Frame")
popupFrame.Size = UDim2.new(0, 250, 0, 100)
popupFrame.Position = UDim2.new(0.5, -125, 0.5, -50) -- Centered
popupFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
popupFrame.BackgroundTransparency = 1 -- Start hidden
popupFrame.Parent = screenGui

local popupStroke = Instance.new("UIStroke")
popupStroke.Thickness = 2
popupStroke.Color = Color3.fromRGB(220, 20, 60) -- Crimson stroke
popupStroke.Parent = popupFrame

local popupCorner = Instance.new("UICorner")
popupCorner.CornerRadius = UDim.new(0, 10)
popupCorner.Parent = popupFrame

local popupText = Instance.new("TextLabel")
popupText.Size = UDim2.new(1, -20, 1, -20)
popupText.Position = UDim2.new(0, 10, 0, 10)
popupText.BackgroundTransparency = 1
popupText.Text = "Made by Day. ENJOY! Day's BP Shitter XD 1.0"
popupText.TextColor3 = Color3.fromRGB(255, 255, 255)
popupText.Font = Enum.Font.GothamBold
popupText.TextSize = 16 -- Slightly smaller for clean look
popupText.TextWrapped = true
popupText.TextScaled = true
popupText.TextTransparency = 1 -- Start hidden
popupText.Parent = popupFrame

-- Smooth Pop-up Animation
task.spawn(function()
for i = 1, 0, -0.1 do
popupFrame.BackgroundTransparency = i
popupText.TextTransparency = i
task.wait(0.02) -- Fast yet smooth
end

task.wait(2) -- Keep for 2 seconds

for i = 0, 1, 0.1 do
popupFrame.BackgroundTransparency = i
popupText.TextTransparency = i
task.wait(0.02) -- Smooth fade-out
end
popupFrame:Destroy()
end)

-- GUI Open/Close Animation
local isUIVisible = false
toggleButton.MouseButton1Click:Connect(function()
isUIVisible = not isUIVisible

if isUIVisible then
frame.Size = UDim2.new(0, 0, 0, 0)
frame.Position = UDim2.new(0.5, 0, 0.5, 0)
frame.BackgroundTransparency = 1
frame.Visible = true

-- Smooth Expand
for i = 0, 1, 0.05 do
local t = math.sin(i * (math.pi / 2))
frame.Size = UDim2.new(0, 300 * t, 0, 250 * t)
frame.Position = UDim2.new(0.5, -150 * t, 0.5, -125 * t)
frame.BackgroundTransparency = 1 - t
task.wait(0.015)
end
else
-- Smooth Shrink
for i = 1, 0, -0.05 do
local t = math.sin(i * (math.pi / 2))
frame.Size = UDim2.new(0, 300 * t, 0, 250 * t)
frame.Position = UDim2.new(0.5, -150 * t, 0.5, -125 * t)
frame.BackgroundTransparency = 1 - t
task.wait(0.015)
end
frame.Visible = false
end
end)
end)
